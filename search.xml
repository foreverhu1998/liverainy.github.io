<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MyBatis学习笔记</title>
      <link href="/2025/12/11/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/12/11/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis学习笔记（含面试题）"><a href="#MyBatis学习笔记（含面试题）" class="headerlink" title="MyBatis学习笔记（含面试题）"></a>MyBatis学习笔记（含面试题）</h1><h1 id="一、核心知识点梳理"><a href="#一、核心知识点梳理" class="headerlink" title="一、核心知识点梳理"></a>一、核心知识点梳理</h1><h2 id="1-MyBatis简介"><a href="#1-MyBatis简介" class="headerlink" title="1. MyBatis简介"></a>1. MyBatis简介</h2><h3 id="1-1-核心定位"><a href="#1-1-核心定位" class="headerlink" title="1.1 核心定位"></a>1.1 核心定位</h3><p>MyBatis是一款优秀的<strong>持久层框架</strong>，它支持定制化SQL、存储过程以及高级映射。MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集的过程，通过XML或注解的方式将Java对象与SQL语句动态映射，简化数据持久化操作。</p><p>核心思想：将SQL与Java代码分离，通过配置文件管理SQL，降低耦合度，提高代码可维护性。</p><h3 id="1-2-与JDBC的对比优势"><a href="#1-2-与JDBC的对比优势" class="headerlink" title="1.2 与JDBC的对比优势"></a>1.2 与JDBC的对比优势</h3><ul><li><p>JDBC需要手动加载驱动、创建连接、编写SQL、设置参数、处理结果集、关闭资源，代码冗余且繁琐；MyBatis通过配置和映射自动完成这些操作，简化开发。</p></li><li><p>JDBC的SQL语句硬编码在Java代码中，修改SQL需重新编译代码；MyBatis的SQL写在XML或注解中，修改无需编译，灵活度高。</p></li><li><p>JDBC需要手动处理参数类型匹配和结果集与Java对象的映射；MyBatis支持自动参数映射和结果集映射，支持复杂对象（一对一、一对多）映射。</p></li><li><p>MyBatis提供缓存机制（一级缓存、二级缓存），提升查询效率；JDBC需手动实现缓存。</p></li></ul><h3 id="1-3-核心依赖（Maven）"><a href="#1-3-核心依赖（Maven）" class="headerlink" title="1.3 核心依赖（Maven）"></a>1.3 核心依赖（Maven）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 最新稳定版 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库驱动（以MySQL为例） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.36<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-MyBatis核心组件"><a href="#2-MyBatis核心组件" class="headerlink" title="2. MyBatis核心组件"></a>2. MyBatis核心组件</h2><p>MyBatis的核心组件围绕“SQL执行流程”展开，各组件分工明确，协同完成数据持久化操作：</p><h3 id="2-1-SqlSessionFactoryBuilder（构建者）"><a href="#2-1-SqlSessionFactoryBuilder（构建者）" class="headerlink" title="2.1 SqlSessionFactoryBuilder（构建者）"></a>2.1 SqlSessionFactoryBuilder（构建者）</h3><p>作用：根据MyBatis核心配置文件（mybatis-config.xml）或配置类，构建SqlSessionFactory对象。</p><p>特点：</p><ul><li><p>属于临时对象，构建完SqlSessionFactory后即可销毁，无需长期持有。</p></li><li><p>核心方法：build(InputStream inputStream)，通过读取配置文件的输入流构建工厂。</p></li></ul><h3 id="2-2-SqlSessionFactory（会话工厂）"><a href="#2-2-SqlSessionFactory（会话工厂）" class="headerlink" title="2.2 SqlSessionFactory（会话工厂）"></a>2.2 SqlSessionFactory（会话工厂）</h3><p>作用：创建SqlSession对象（数据库会话），是MyBatis的核心工厂类。</p><p>特点：</p><ul><li><p>属于单例对象，整个应用程序中只需创建一个，负责管理数据库连接池。</p></li><li><p>核心方法：openSession()，创建SqlSession对象（默认手动提交事务）；openSession(true)，创建自动提交事务的SqlSession。</p></li></ul><h3 id="2-3-SqlSession（数据库会话）"><a href="#2-3-SqlSession（数据库会话）" class="headerlink" title="2.3 SqlSession（数据库会话）"></a>2.3 SqlSession（数据库会话）</h3><p>作用：代表与数据库的一次会话，是MyBatis操作数据库的核心对象，可执行SQL语句、管理事务。</p><p>特点：</p><ul><li><p>属于线程不安全对象，每次数据库操作需创建新的SqlSession，使用完毕后必须关闭（避免资源泄漏）。</p></li><li><p>核心方法：selectOne()（查询单个结果）、selectList()（查询集合结果）、insert()、update()、delete()（增删改操作）、commit()（提交事务）、rollback()（回滚事务）、getMapper()（获取Mapper接口代理对象）。</p></li></ul><h3 id="2-4-Mapper接口（映射器）"><a href="#2-4-Mapper接口（映射器）" class="headerlink" title="2.4 Mapper接口（映射器）"></a>2.4 Mapper接口（映射器）</h3><p>作用：定义数据操作的接口，MyBatis通过动态代理机制自动生成接口的实现类，实现SQL与Java方法的映射。</p><p>特点：</p><ul><li><p>接口无需手动实现，MyBatis通过XML或注解绑定SQL语句。</p></li><li><p>方法名需与XML映射文件中的SQL语句ID一致，参数类型和返回值类型需与SQL的参数和结果集匹配。</p></li></ul><h3 id="2-5-核心配置文件（mybatis-config-xml）"><a href="#2-5-核心配置文件（mybatis-config-xml）" class="headerlink" title="2.5 核心配置文件（mybatis-config.xml）"></a>2.5 核心配置文件（mybatis-config.xml）</h3><p>作用：配置MyBatis的核心参数，如数据库连接信息、映射器路径、缓存策略、类型别名等。</p><p>核心配置节点：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 环境配置（可配置多环境，默认激活一个） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 事务管理类型：JDBC（手动）/MANAGED（交给容器） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 数据源类型：POOLED（连接池）/UNPOOLED（非连接池）/JNDI（容器数据源） --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis_db&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 映射器配置（指定XML映射文件或Mapper接口路径） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/UserMapper.xml&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 基于XML文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 基于注解（接口全类名） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.example.mapper&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 扫描指定包下的所有Mapper接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 类型别名（简化全类名编写） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.example.pojo.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;User&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.example.pojo&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 扫描包，别名默认为类名首字母小写（User→user） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-6-映射文件（XXXMapper-xml）"><a href="#2-6-映射文件（XXXMapper-xml）" class="headerlink" title="2.6 映射文件（XXXMapper.xml）"></a>2.6 映射文件（XXXMapper.xml）</h3><p>作用：存储SQL语句，定义Java对象与SQL参数、结果集的映射关系，是MyBatis中SQL与代码分离的核心载体。</p><p>核心节点：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> </span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace：绑定对应的Mapper接口全类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 结果集映射：解决Java属性名与数据库字段名不一致问题 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 主键映射 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 普通字段映射 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 查询：id对应Mapper接口的方法名，resultMap指定映射规则 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">        SELECT user_id, user_name, age FROM user WHERE user_id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 新增：useGeneratedKeys获取自增主键，keyProperty绑定Java属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;userId&quot;</span>&gt;</span></span><br><span class="line">        INSERT INTO user (user_name, age) VALUES (#&#123;userName&#125;, #&#123;age&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 修改 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        UPDATE user SET user_name = #&#123;userName&#125;, age = #&#123;age&#125; WHERE user_id = #&#123;userId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 删除 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        DELETE FROM user WHERE user_id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-MyBatis核心工作原理"><a href="#3-MyBatis核心工作原理" class="headerlink" title="3. MyBatis核心工作原理"></a>3. MyBatis核心工作原理</h2><p>MyBatis的工作流程可分为“初始化阶段”和“SQL执行阶段”两大步骤，核心是“配置解析”和“动态代理”：</p><h3 id="3-1-初始化阶段（启动时）"><a href="#3-1-初始化阶段（启动时）" class="headerlink" title="3.1 初始化阶段（启动时）"></a>3.1 初始化阶段（启动时）</h3><ol><li><p>加载核心配置文件：SqlSessionFactoryBuilder读取mybatis-config.xml，解析配置信息（环境、数据源、映射器等）。</p></li><li><p>创建SqlSessionFactory：通过配置信息初始化数据源（连接池）和事务管理器，生成SqlSessionFactory单例对象。</p></li><li><p>解析映射文件：SqlSessionFactory加载XXXMapper.xml，解析SQL语句、参数映射、结果集映射，存储到Configuration对象中（MyBatis的核心配置容器）。</p></li></ol><h3 id="3-2-SQL执行阶段（运行时）"><a href="#3-2-SQL执行阶段（运行时）" class="headerlink" title="3.2 SQL执行阶段（运行时）"></a>3.2 SQL执行阶段（运行时）</h3><ol><li><p>创建SqlSession：通过SqlSessionFactory.openSession()创建SqlSession，关联数据库连接，开启事务。</p></li><li><p>获取Mapper代理对象：SqlSession.getMapper(Mapper接口.class)，MyBatis通过JDK动态代理生成Mapper接口的代理实现类（MapperProxy）。</p></li><li><p>执行SQL：调用Mapper接口的方法，代理对象拦截方法调用，从Configuration中获取对应的SQL语句和映射规则。</p></li><li><p>参数处理：将Java方法参数转换为SQL参数，通过参数处理器（ParameterHandler）设置到PreparedStatement中。</p></li><li><p>执行SQL并处理结果：通过执行器（Executor）执行SQL，获取结果集，通过结果集处理器（ResultSetHandler）将结果集映射为Java对象。</p></li><li><p>事务管理：执行完成后，通过SqlSession.commit()提交事务或rollback()回滚事务，关闭SqlSession释放资源。</p></li></ol><h2 id="4-MyBatis核心特性"><a href="#4-MyBatis核心特性" class="headerlink" title="4. MyBatis核心特性"></a>4. MyBatis核心特性</h2><h3 id="4-1-动态SQL"><a href="#4-1-动态SQL" class="headerlink" title="4.1 动态SQL"></a>4.1 动态SQL</h3><p>MyBatis提供动态SQL标签，可根据参数条件动态拼接SQL语句，避免手动拼接SQL的繁琐和SQL注入风险。</p><p>常用动态SQL标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT user_id, user_name, age FROM user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span> <span class="comment">&lt;!-- 自动拼接WHERE关键字，去除多余AND/OR --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userName != null and userName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            AND user_name LIKE CONCAT(&#x27;%&#x27;, #&#123;userName&#125;, &#x27;%&#x27;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null&quot;</span>&gt;</span></span><br><span class="line">            AND age = #&#123;age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">choose</span>&gt;</span> <span class="comment">&lt;!-- 类似switch-case，只执行一个when --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;sortBy == &#x27;age&#x27;&quot;</span>&gt;</span>ORDER BY age ASC<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;sortBy == &#x27;userName&#x27;&quot;</span>&gt;</span>ORDER BY user_name ASC<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span>ORDER BY user_id ASC<span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 批量删除：foreach遍历集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteBatchUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.util.List&quot;</span>&gt;</span></span><br><span class="line">    DELETE FROM user WHERE user_id IN</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-2-结果集映射"><a href="#4-2-结果集映射" class="headerlink" title="4.2 结果集映射"></a>4.2 结果集映射</h3><p>解决Java对象属性名与数据库字段名不一致的问题，常用两种方式：</p><ol><li><p>使用resultMap标签：在XML中定义字段名与属性名的映射关系（推荐，适合复杂对象）。</p></li><li><p>使用别名：在SQL语句中给字段起别名，别名与Java属性名一致（适合简单场景），如SELECT user_id AS userId, user_name AS userName FROM user。</p></li></ol><p>复杂映射（关联查询）：</p><ul><li><p>一对一（association）：如用户与身份证信息，使用<association>标签映射关联对象。</p></li><li><p>一对多（collection）：如用户与订单列表，使用<collection>标签映射关联集合。</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 一对多：用户与订单 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserOrderMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- collection映射订单集合 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orderList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Order&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;orderId&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;order_no&quot;</span> <span class="attr">property</span>=<span class="string">&quot;orderNo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserWithOrders&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserOrderMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT u.user_id, u.user_name, o.order_id, o.order_no </span><br><span class="line">    FROM user u LEFT JOIN order o ON u.user_id = o.user_id </span><br><span class="line">    WHERE u.user_id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-3-缓存机制"><a href="#4-3-缓存机制" class="headerlink" title="4.3 缓存机制"></a>4.3 缓存机制</h3><p>MyBatis提供两级缓存，用于减少数据库查询次数，提升性能：</p><h4 id="4-3-1-一级缓存（本地缓存）"><a href="#4-3-1-一级缓存（本地缓存）" class="headerlink" title="4.3.1 一级缓存（本地缓存）"></a>4.3.1 一级缓存（本地缓存）</h4><ul><li><p>作用域：SqlSession级别，默认开启，不可关闭。</p></li><li><p>原理：同一个SqlSession中，执行相同的查询SQL（参数一致），第一次查询从数据库获取结果并缓存到SqlSession中，后续查询直接从缓存获取，无需访问数据库。</p></li><li><p>失效场景：执行insert&#x2F;update&#x2F;delete操作（会清空一级缓存）、手动调用SqlSession.clearCache()、SqlSession关闭。</p></li></ul><h4 id="4-3-2-二级缓存（全局缓存）"><a href="#4-3-2-二级缓存（全局缓存）" class="headerlink" title="4.3.2 二级缓存（全局缓存）"></a>4.3.2 二级缓存（全局缓存）</h4><ul><li><p>作用域：Mapper接口级别（同一个namespace），默认关闭，需手动开启。</p></li><li><p>开启方式：① 核心配置文件中设置<setting name="cacheEnabled" value="true"/>（默认true，可省略）；② 映射文件中添加<cache/>标签。</p></li><li><p>原理：多个SqlSession共享同一个Mapper的缓存，查询结果先存入一级缓存，当SqlSession关闭时，一级缓存的内容会同步到二级缓存。</p></li><li><p>注意事项：缓存的对象需实现Serializable接口（支持序列化，便于缓存存储）；执行insert&#x2F;update&#x2F;delete操作会清空当前Mapper的二级缓存。</p></li></ul><h3 id="4-4-分页机制"><a href="#4-4-分页机制" class="headerlink" title="4.4 分页机制"></a>4.4 分页机制</h3><p>MyBatis支持两种分页方式：</p><ol><li><p>RowBounds分页（内存分页）：通过RowBounds对象设置起始行和查询条数，原理是查询全部结果后在内存中截取，效率低，适合小数据量场景。</p></li><li><p>插件分页（物理分页，推荐）：使用第三方插件（如PageHelper），通过拦截SQL语句动态添加LIMIT（MySQL）、ROWNUM（Oracle）等分页语法，直接从数据库查询分页结果，效率高。</p></li></ol><h2 id="5-MyBatis注解开发"><a href="#5-MyBatis注解开发" class="headerlink" title="5. MyBatis注解开发"></a>5. MyBatis注解开发</h2><p>MyBatis支持通过注解直接在Mapper接口上编写SQL，无需XML映射文件，适合简单SQL场景，复杂SQL仍推荐XML方式。</p><p>常用注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">// 查询（@Select）</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT user_id AS userId, user_name AS userName, age FROM user WHERE user_id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新增（@Insert）</span></span><br><span class="line">    <span class="meta">@Insert(&quot;INSERT INTO user (user_name, age) VALUES (#&#123;userName&#125;, #&#123;age&#125;)&quot;)</span></span><br><span class="line">    <span class="meta">@Options(useGeneratedKeys = true, keyProperty = &quot;userId&quot;)</span> <span class="comment">// 获取自增主键</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">addUser</span><span class="params">(User user)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改（@Update）</span></span><br><span class="line">    <span class="meta">@Update(&quot;UPDATE user SET user_name = #&#123;userName&#125;, age = #&#123;age&#125; WHERE user_id = #&#123;userId&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateUser</span><span class="params">(User user)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除（@Delete）</span></span><br><span class="line">    <span class="meta">@Delete(&quot;DELETE FROM user WHERE user_id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteUser</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 动态SQL（@SelectProvider，通过类的方法生成SQL）</span></span><br><span class="line">    <span class="meta">@SelectProvider(type = UserSqlProvider.class, method = &quot;getUserListSql&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">getUserList</span><span class="params">(User user)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 动态SQL提供者类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UserSqlProvider</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getUserListSql</span><span class="params">(User user)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;&#123;</span><br><span class="line">                SELECT(<span class="string">&quot;user_id, user_name, age&quot;</span>);</span><br><span class="line">                FROM(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (user.getUserName() != <span class="literal">null</span> &amp;&amp; !user.getUserName().isEmpty()) &#123;</span><br><span class="line">                    WHERE(<span class="string">&quot;user_name LIKE CONCAT(&#x27;%&#x27;, #&#123;userName&#125;, &#x27;%&#x27;)&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (user.getAge() != <span class="literal">null</span>) &#123;</span><br><span class="line">                    WHERE(<span class="string">&quot;age = #&#123;age&#125;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;&#125;.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、面试高频问题及解析"><a href="#二、面试高频问题及解析" class="headerlink" title="二、面试高频问题及解析"></a>二、面试高频问题及解析</h1><h2 id="1-基础概念类"><a href="#1-基础概念类" class="headerlink" title="1. 基础概念类"></a>1. 基础概念类</h2><h3 id="Q1：MyBatis是什么？它的核心优势是什么？"><a href="#Q1：MyBatis是什么？它的核心优势是什么？" class="headerlink" title="Q1：MyBatis是什么？它的核心优势是什么？"></a>Q1：MyBatis是什么？它的核心优势是什么？</h3><p>解析：</p><p>MyBatis是一款持久层框架，支持定制化SQL、存储过程和高级映射，通过XML或注解将Java对象与SQL动态映射，简化JDBC开发。</p><p>核心优势：</p><ul><li><p>SQL与Java代码分离，便于维护和修改，无需重新编译代码。</p></li><li><p>自动完成参数映射和结果集映射，避免手动处理JDBC的参数和结果集，减少冗余代码。</p></li><li><p>支持动态SQL，可根据参数条件动态拼接SQL，灵活应对复杂查询场景。</p></li><li><p>提供缓存机制（一级、二级），提升查询效率。</p></li><li><p>支持复杂映射（一对一、一对多），满足复杂业务场景需求。</p></li><li><p>轻量级框架，配置简单，学习成本低，易于集成到Spring等主流框架。</p></li></ul><h3 id="Q2：MyBatis与Hibernate的区别是什么？适用场景分别是什么？"><a href="#Q2：MyBatis与Hibernate的区别是什么？适用场景分别是什么？" class="headerlink" title="Q2：MyBatis与Hibernate的区别是什么？适用场景分别是什么？"></a>Q2：MyBatis与Hibernate的区别是什么？适用场景分别是什么？</h3><p>解析：</p><p>两者均为持久层框架，核心区别在于“SQL控制粒度”和“开发模式”：</p><table><thead><tr><th>维度</th><th>MyBatis</th><th>Hibernate</th></tr></thead><tbody><tr><td>SQL控制</td><td>手动编写SQL，灵活度高，可优化SQL性能</td><td>自动生成SQL，无需手动编写，灵活度低</td></tr><tr><td>开发模式</td><td>半ORM（对象关系映射），需要关注SQL和数据库细节</td><td>全ORM，完全面向对象开发，无需关注数据库细节</td></tr><tr><td>学习成本</td><td>低，重点掌握SQL和映射配置</td><td>高，需要掌握HQL、缓存、关联映射等复杂特性</td></tr><tr><td>性能优化</td><td>手动优化SQL，针对性强，适合复杂查询场景</td><td>自动生成的SQL可能低效，优化难度大，需通过复杂配置优化</td></tr><tr><td>适用场景</td><td>需求多变、SQL复杂的项目（如电商、金融）；对性能要求高，需要手动优化SQL的场景</td><td>需求稳定、SQL简单的项目（如后台管理系统）；快速开发原型的场景</td></tr></tbody></table><h2 id="2-核心组件与工作原理类"><a href="#2-核心组件与工作原理类" class="headerlink" title="2. 核心组件与工作原理类"></a>2. 核心组件与工作原理类</h2><h3 id="Q1：MyBatis的核心组件有哪些？各自的作用是什么？"><a href="#Q1：MyBatis的核心组件有哪些？各自的作用是什么？" class="headerlink" title="Q1：MyBatis的核心组件有哪些？各自的作用是什么？"></a>Q1：MyBatis的核心组件有哪些？各自的作用是什么？</h3><p>解析：</p><ol><li><p>SqlSessionFactoryBuilder：构建者，根据核心配置文件构建SqlSessionFactory，构建完成后可销毁。</p></li><li><p>SqlSessionFactory：会话工厂，单例对象，管理数据库连接池，负责创建SqlSession。</p></li><li><p>SqlSession：数据库会话，线程不安全，代表与数据库的一次交互，可执行SQL、管理事务。</p></li><li><p>Mapper接口：映射器，定义数据操作接口，MyBatis通过动态代理生成实现类，绑定SQL语句。</p></li><li><p>Configuration：核心配置容器，存储MyBatis的所有配置信息（环境、映射器、SQL语句等）。</p></li><li><p>Executor：执行器，SqlSession的底层核心组件，负责执行SQL语句，管理一级缓存。</p></li><li><p>ParameterHandler：参数处理器，将Java方法参数转换为SQL参数，设置到PreparedStatement中。</p></li><li><p>ResultSetHandler：结果集处理器，将SQL查询结果集映射为Java对象。</p></li></ol><h3 id="Q2：MyBatis的工作原理是什么？请简述完整的执行流程。"><a href="#Q2：MyBatis的工作原理是什么？请简述完整的执行流程。" class="headerlink" title="Q2：MyBatis的工作原理是什么？请简述完整的执行流程。"></a>Q2：MyBatis的工作原理是什么？请简述完整的执行流程。</h3><p>解析：</p><p>MyBatis的工作流程分为“初始化阶段”和“SQL执行阶段”：</p><ol><li><p>初始化阶段：<br>加载配置：SqlSessionFactoryBuilder读取mybatis-config.xml和XXXMapper.xml，解析配置信息（数据源、事务、SQL语句、映射规则等）。</p></li><li><p>创建SqlSessionFactory：根据解析后的配置信息，初始化数据源和事务管理器，生成SqlSessionFactory单例对象。</p></li><li><p>存储配置：将解析后的SQL语句、映射规则等存入Configuration对象中，供运行时使用。</p></li><li><p>SQL执行阶段：<br>创建SqlSession：通过SqlSessionFactory.openSession()创建SqlSession，关联数据库连接，开启事务。</p></li><li><p>获取Mapper代理：调用SqlSession.getMapper()，MyBatis通过JDK动态代理生成Mapper接口的代理对象（MapperProxy）。</p></li><li><p>拦截方法调用：调用Mapper接口方法时，代理对象拦截调用，从Configuration中获取对应的SQL语句和映射规则。</p></li><li><p>参数处理：ParameterHandler将Java方法参数转换为SQL参数，设置到PreparedStatement。</p></li><li><p>执行SQL：Executor执行SQL语句，获取结果集。</p></li><li><p>结果映射：ResultSetHandler将结果集映射为Java对象。</p></li><li><p>事务管理：执行完成后，通过SqlSession.commit()&#x2F;rollback()管理事务，关闭SqlSession释放资源。</p></li></ol><h3 id="Q3：MyBatis的Mapper接口为什么不需要实现类？"><a href="#Q3：MyBatis的Mapper接口为什么不需要实现类？" class="headerlink" title="Q3：MyBatis的Mapper接口为什么不需要实现类？"></a>Q3：MyBatis的Mapper接口为什么不需要实现类？</h3><p>解析：</p><p>MyBatis通过<strong>JDK动态代理机制</strong>自动生成Mapper接口的实现类，无需手动编写：</p><ol><li><p>当调用SqlSession.getMapper(Mapper接口.class)时，MyBatis会创建一个实现了该接口的代理对象（MapperProxy）。</p></li><li><p>代理对象会拦截接口中所有方法的调用，根据方法名从Configuration中找到对应的SQL语句和映射规则。</p></li><li><p>代理对象通过Executor、ParameterHandler、ResultSetHandler等组件完成SQL执行和结果映射，最终将结果返回给调用者。</p></li></ol><p>核心优势：简化开发，避免编写大量重复的实现类代码，同时实现SQL与Java代码的解耦。</p><h2 id="3-映射与SQL相关类"><a href="#3-映射与SQL相关类" class="headerlink" title="3. 映射与SQL相关类"></a>3. 映射与SQL相关类</h2><h3 id="Q1：MyBatis中如何解决Java属性名与数据库字段名不一致的问题？"><a href="#Q1：MyBatis中如何解决Java属性名与数据库字段名不一致的问题？" class="headerlink" title="Q1：MyBatis中如何解决Java属性名与数据库字段名不一致的问题？"></a>Q1：MyBatis中如何解决Java属性名与数据库字段名不一致的问题？</h3><p>解析：</p><p>常用三种解决方案，优先级：resultMap &gt; SQL别名 &gt; 开启驼峰命名自动映射：</p><ol><li>使用resultMap标签（推荐）：在XML映射文件中定义resultMap，明确指定数据库字段名（column）与Java属性名（property）的映射关系。<br>&#96;<resultMap id="UserMap" type="User"><id column="user_id" property="userId"/><result column="user_name" property="userName"/></resultMap></li></ol><select id="getUserById" parameterType="int" resultMap="UserMap">    SELECT user_id, user_name FROM user WHERE user_id = #{id}&lt;/select&gt;`<ol start="2"><li><p>SQL语句中使用别名：给数据库字段起与Java属性名一致的别名，适合简单场景。<br><code>&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt;  SELECT user_id AS userId, user_name AS userName FROM user WHERE user_id = #{id} &lt;/select&gt;</code></p></li><li><p>开启驼峰命名自动映射：MyBatis支持自动将数据库的下划线命名（如user_id）转换为Java的驼峰命名（userId），需在核心配置文件中开启：<br>&#96;<configuration></p><settings>    <setting name="mapUnderscoreToCamelCase" value="true"/></settings></configuration>`注意：仅适用于“下划线命名”与“驼峰命名”严格对应的场景（如user_name → userName）。</li></ol><h3 id="Q2：MyBatis的动态SQL有哪些标签？分别作用是什么？"><a href="#Q2：MyBatis的动态SQL有哪些标签？分别作用是什么？" class="headerlink" title="Q2：MyBatis的动态SQL有哪些标签？分别作用是什么？"></a>Q2：MyBatis的动态SQL有哪些标签？分别作用是什么？</h3><p>解析：</p><p>动态SQL标签用于根据参数条件动态拼接SQL，避免手动拼接导致的语法错误和SQL注入风险，常用标签：</p><ul><li><p><if>：条件判断，满足test属性中的表达式则拼接标签内的SQL。<br><code>&lt;if test=&quot;userName != null and userName != &#39;&#39;&quot;&gt; AND user_name LIKE CONCAT(&#39;%&#39;, #{userName}, &#39;%&#39;) &lt;/if&gt;</code></p></li><li><p><where>：自动拼接WHERE关键字，智能去除标签内开头的多余AND&#x2F;OR，替代手动写WHERE 1&#x3D;1。</p></li><li><p><choose><when><otherwise>：类似Java的switch-case，只执行第一个满足条件的<when>，都不满足则执行<otherwise>。</p></li><li><p><foreach>：遍历集合（List、Array、Map），常用于批量操作（批量删除、批量插入），核心属性：<br>collection：集合参数名（如list、array）。</p></li><li><p>item：遍历的单个元素别名。</p></li><li><p>open：拼接SQL的开头字符（如(）。</p></li><li><p>separator：元素之间的分隔符（如,）。</p></li><li><p>close：拼接SQL的结尾字符（如)）。</p></li></ul><p><set>：用于update语句，自动拼接SET关键字，去除多余的逗号，适合动态更新字段。<br>        <code>&lt;update id=&quot;updateUser&quot; parameterType=&quot;User&quot;&gt;     UPDATE user     &lt;set&gt;         &lt;if test=&quot;userName != null&quot;&gt;user_name = #{userName},&lt;/if&gt;         &lt;if test=&quot;age != null&quot;&gt;age = #{age}&lt;/if&gt;     &lt;/set&gt;     WHERE user_id = #{userId} &lt;/update&gt;</code></p><h3 id="Q3：MyBatis中-和-的区别是什么？使用时需要注意什么？"><a href="#Q3：MyBatis中-和-的区别是什么？使用时需要注意什么？" class="headerlink" title="Q3：MyBatis中#{}和${}的区别是什么？使用时需要注意什么？"></a>Q3：MyBatis中#{}和${}的区别是什么？使用时需要注意什么？</h3><p>解析：</p><p>两者均为MyBatis的参数占位符，核心区别在于“参数解析方式”和“SQL注入风险”：</p><table><thead><tr><th>维度</th><th>#{}</th><th>${}</th></tr></thead><tbody><tr><td>解析方式</td><td>将参数解析为PreparedStatement的参数占位符（?），自动进行参数类型匹配和转义</td><td>将参数直接拼接为SQL字符串，不进行转义</td></tr><tr><td>SQL注入风险</td><td>无风险，参数被当作普通字符串处理，避免注入攻击</td><td>有风险，参数直接拼接进SQL，若参数为用户输入，可能被篡改SQL逻辑</td></tr><tr><td>适用场景</td><td>传递SQL参数（如WHERE条件、INSERT VALUES），绝大多数场景推荐使用</td><td>动态拼接SQL片段（如表名、列名、排序方式），需确保参数安全（非用户输入）</td></tr><tr><td>示例</td><td>SELECT * FROM user WHERE id &#x3D; #{id} → 解析为 SELECT * FROM user WHERE id &#x3D; ?</td><td>SELECT * FROM ${tableName} → 若tableName&#x3D;user，解析为 SELECT * FROM user</td></tr><tr><td>注意事项：优先使用#{}，避免使用${}；若必须使用${}，需对参数进行严格校验，确保参数不是用户可控的输入，防止SQL注入。</td><td></td><td></td></tr></tbody></table><h2 id="4-缓存相关类"><a href="#4-缓存相关类" class="headerlink" title="4. 缓存相关类"></a>4. 缓存相关类</h2><h3 id="Q1：MyBatis的一级缓存和二级缓存有什么区别？"><a href="#Q1：MyBatis的一级缓存和二级缓存有什么区别？" class="headerlink" title="Q1：MyBatis的一级缓存和二级缓存有什么区别？"></a>Q1：MyBatis的一级缓存和二级缓存有什么区别？</h3><p>解析：</p><table><thead><tr><th>维度</th><th>一级缓存（本地缓存）</th><th>二级缓存（全局缓存）</th></tr></thead><tbody><tr><td>作用域</td><td>SqlSession级别，仅同一个SqlSession内有效</td><td>Mapper接口级别（namespace），多个SqlSession共享</td></tr><tr><td>开启方式</td><td>默认开启，不可关闭</td><td>默认关闭，需在映射文件中添加<cache/>标签开启</td></tr><tr><td>缓存存储位置</td><td>SqlSession对象中</td><td>Configuration对象中（对应Mapper的namespace下）</td></tr><tr><td>数据同步时机</td><td>查询时存入，insert&#x2F;update&#x2F;delete或SqlSession关闭时清空</td><td>SqlSession关闭时，将一级缓存数据同步到二级缓存；insert&#x2F;update&#x2F;delete时清空当前Mapper的二级缓存</td></tr><tr><td>序列化要求</td><td>无需实现Serializable接口</td><td>需要实现Serializable接口（支持序列化存储）</td></tr><tr><td>使用场景</td><td>同一事务内的多次查询，减少数据库访问</td><td>多个事务共享的查询数据（如字典数据），提升全局查询效率</td></tr></tbody></table><h3 id="Q2：MyBatis的一级缓存什么时候会失效？"><a href="#Q2：MyBatis的一级缓存什么时候会失效？" class="headerlink" title="Q2：MyBatis的一级缓存什么时候会失效？"></a>Q2：MyBatis的一级缓存什么时候会失效？</h3><p>解析：</p><p>一级缓存默认开启，在以下场景会失效：</p><ol><li><p>执行insert、update、delete操作：MyBatis会自动清空当前SqlSession的一级缓存，避免缓存数据与数据库数据不一致。</p></li><li><p>手动调用SqlSession.clearCache()方法：主动清空一级缓存。</p></li><li><p>SqlSession关闭：SqlSession关闭后，一级缓存随之销毁，数据丢失。</p></li><li><p>查询参数或SQL语句不同：一级缓存的key由SQL语句、参数、RowBounds等组成，若任意条件不同，视为不同的查询，不会命中缓存。</p></li><li><p>跨SqlSession查询：不同的SqlSession拥有独立的一级缓存，无法共享数据。</p></li></ol><h2 id="5-综合应用类"><a href="#5-综合应用类" class="headerlink" title="5. 综合应用类"></a>5. 综合应用类</h2><h3 id="Q1：MyBatis如何实现分页？有哪些方式？"><a href="#Q1：MyBatis如何实现分页？有哪些方式？" class="headerlink" title="Q1：MyBatis如何实现分页？有哪些方式？"></a>Q1：MyBatis如何实现分页？有哪些方式？</h3><p>解析：</p><p>MyBatis支持两种分页方式，核心区别在于“分页时机”（内存中分页 vs 数据库中分页）：</p><ol><li><p>RowBounds分页（内存分页，不推荐）：<br>原理：通过RowBounds对象设置起始行（offset）和查询条数（limit），MyBatis先查询出全部结果，再在内存中截取指定范围的数据。</p></li><li><p>缺点：大数据量场景下效率极低，会占用大量内存。</p></li></ol><p>插件分页（物理分页，推荐）：<br>    原理：使用第三方插件（如PageHelper），通过MyBatis的插件机制拦截SQL语句，动态添加分页语法（如MySQL的LIMIT、Oracle的ROWNUM），直接从数据库查询分页结果。</p><h3 id="Q2：MyBatis如何集成Spring？核心配置有哪些？"><a href="#Q2：MyBatis如何集成Spring？核心配置有哪些？" class="headerlink" title="Q2：MyBatis如何集成Spring？核心配置有哪些？"></a>Q2：MyBatis如何集成Spring？核心配置有哪些？</h3><p>解析：</p><p>MyBatis与Spring集成的核心是“将MyBatis的核心组件（SqlSessionFactory、SqlSession、Mapper）交给Spring容器管理”，实现依赖注入和事务统一管理，核心配置步骤：</p><ol><li><p>导入集成依赖（Maven）：<br>&#96;<!-- MyBatis-Spring集成包 --></p><dependency><groupId>org.mybatis</groupId><artifactId>mybatis-spring</artifactId><version>2.0.7</version></dependency><!-- Spring-JDBC（事务管理） --><dependency><groupId>org.springframework</groupId><artifactId>spring-jdbc</artifactId><version>5.3.29</version></dependency>`</li><li><p>Spring配置文件（applicationContext.xml）核心配置：<br>配置数据源（交给Spring管理，替代MyBatis的dataSource配置）：<br> &#96;<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"></p><property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/><property name="url" value="jdbc:mysql://localhost:3306/mybatis_db"/><property name="username" value="root"/><property name="password" value="123456"/></bean>`</li><li><p>配置SqlSessionFactoryBean（替代SqlSessionFactoryBuilder，创建SqlSessionFactory）</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP、HTTPS和TCP学习笔记</title>
      <link href="/2025/12/11/HTTP%E3%80%81HTTPS%E5%92%8CTCP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/12/11/HTTP%E3%80%81HTTPS%E5%92%8CTCP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、核心协议知识点梳理"><a href="#一、核心协议知识点梳理" class="headerlink" title="一、核心协议知识点梳理"></a>一、核心协议知识点梳理</h1><h2 id="1-TCP协议（传输控制协议）"><a href="#1-TCP协议（传输控制协议）" class="headerlink" title="1. TCP协议（传输控制协议）"></a>1. TCP协议（传输控制协议）</h2><h3 id="1-1-核心定位"><a href="#1-1-核心定位" class="headerlink" title="1.1 核心定位"></a>1.1 核心定位</h3><p>TCP是面向连接的、可靠的、基于字节流的传输层协议，位于IP协议之上，应用层协议（如HTTP）之下，负责在两个通信端点之间建立可靠的字节流传输通道。</p><h3 id="1-2-核心特点"><a href="#1-2-核心特点" class="headerlink" title="1.2 核心特点"></a>1.2 核心特点</h3><ul><li><p><strong>面向连接</strong>：通信前必须通过“三次握手”建立连接，通信结束后通过“四次挥手”释放连接。</p></li><li><p><strong>可靠传输</strong>：通过序列号、确认应答、重传机制、流量控制、拥塞控制等保证数据不丢失、不重复、按序到达。</p></li><li><p><strong>面向字节流</strong>：不关心应用层数据的具体含义，将应用层数据视为连续的字节流，拆分为TCP报文段传输。</p></li><li><p><strong>双工通信</strong>：通信双方可同时发送和接收数据。</p></li><li><p><strong>点到点通信</strong>：仅支持两个端点之间的通信，不支持多播或广播。</p></li></ul><h3 id="1-3-关键机制"><a href="#1-3-关键机制" class="headerlink" title="1.3 关键机制"></a>1.3 关键机制</h3><ol><li><p>**三次握手（建立连接）**目的：确保双方收发能力正常，协商初始序列号（ISN）。过程：</p><ol><li><p>客户端 → 服务器：SYN&#x3D;1，Seq&#x3D;x（客户端初始序列号）</p></li><li><p>服务器 → 客户端：SYN&#x3D;1，ACK&#x3D;1，Seq&#x3D;y，Ack&#x3D;x+1（确认客户端，发送服务器初始序列号）</p></li><li><p>客户端 → 服务器：ACK&#x3D;1，Seq&#x3D;x+1，Ack&#x3D;y+1（确认服务器，连接建立）</p></li></ol><p><img src="https://liverainy-blog-images.oss-cn-chengdu.aliyuncs.com/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/5acdd551a7f14c01ab549e6c1e7420b9.png"></p></li><li><p>**四次挥手（释放连接）**目的：确保双方数据都已传输完成，正常释放连接。过程：</p><ol><li><p>客户端 → 服务器：FIN&#x3D;1，Seq&#x3D;u（客户端无数据发送，请求释放）</p></li><li><p>服务器 → 客户端：ACK&#x3D;1，Seq&#x3D;v，Ack&#x3D;u+1（确认客户端请求，此时服务器可能仍有数据发送）</p></li><li><p>服务器 → 客户端：FIN&#x3D;1，ACK&#x3D;1，Seq&#x3D;w，Ack&#x3D;u+1（服务器无数据发送，请求释放）</p></li><li><p>客户端 → 服务器：ACK&#x3D;1，Seq&#x3D;u+1，Ack&#x3D;w+1（确认服务器请求，等待2MSL后释放连接）</p></li></ol><p><img src="https://liverainy-blog-images.oss-cn-chengdu.aliyuncs.com/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/f1bd782514691276991d5215a41d1e3d.png"></p></li><li><p><strong>流量控制</strong>：通过滑动窗口机制，让发送方的发送速率适配接收方的接收能力，避免接收方缓冲区溢出。接收方通过ACK报文告知发送方自己的接收窗口大小。</p></li><li><p><strong>拥塞控制</strong>：通过慢启动、拥塞避免、快速重传、快速恢复等算法，避免网络因发送方数据过多而拥塞。</p></li><li><p><strong>重传机制</strong>：若发送方未在超时时间内收到确认应答，会重传对应报文段；快速重传机制可在收到3个重复ACK时直接重传，无需等待超时。</p></li></ol><h2 id="2-HTTP协议（超文本传输协议）"><a href="#2-HTTP协议（超文本传输协议）" class="headerlink" title="2. HTTP协议（超文本传输协议）"></a>2. HTTP协议（超文本传输协议）</h2><h3 id="2-1-核心定位"><a href="#2-1-核心定位" class="headerlink" title="2.1 核心定位"></a>2.1 核心定位</h3><p>HTTP是基于TCP的应用层协议，用于规范客户端（如浏览器）与服务器之间的超文本（文本、图片、视频等）传输格式和交互流程，是Web服务的基础。</p><h3 id="2-2-核心特点"><a href="#2-2-核心特点" class="headerlink" title="2.2 核心特点"></a>2.2 核心特点</h3><ul><li><p><strong>无连接</strong>：HTTP&#x2F;1.0默认每次请求-响应后关闭TCP连接；HTTP&#x2F;1.1支持长连接（Keep-Alive），可复用TCP连接处理多个请求。</p></li><li><p><strong>无状态</strong>：服务器不保存客户端的上下文信息，每次请求都是独立的。需通过Cookie、Session等机制实现状态保持。</p></li><li><p><strong>简单灵活</strong>：请求格式简单（方法+URL+协议版本+请求头+请求体），支持多种数据格式。</p></li><li><p><strong>明文传输</strong>：数据在传输过程中未加密，易被窃听、篡改、伪造。</p></li></ul><h3 id="2-3-核心组成"><a href="#2-3-核心组成" class="headerlink" title="2.3 核心组成"></a>2.3 核心组成</h3><ol><li><p><strong>请求报文结构</strong></p><p><code>请求行：Method Request-URI HTTP-Version (如：GET /index.html HTTP/1.1) 请求头：Key: Value (如：Host: www.example.com, User-Agent: Chrome/100.0.0.0) 空行（分隔请求头和请求体） 请求体（可选，如POST请求的表单数据、JSON数据）</code></p></li><li><p><strong>响应报文结构</strong></p><p><code>状态行：HTTP-Version Status-Code Reason-Phrase (如：HTTP/1.1 200 OK) 响应头：Key: Value (如：Content-Type: text/html; charset=utf-8, Content-Length: 1024) 空行（分隔响应头和响应体） 响应体（如HTML页面、JSON数据、图片等）</code></p></li><li><p><strong>常用请求方法</strong></p><ol><li>GET：获取资源（如请求网页、图片），请求参数拼接在URL后，长度有限制，幂等（多次请求结果一致）。</li><li>POST：提交资源（如表单提交、上传文件），请求参数在请求体中，长度无限制，非幂等。</li><li>PUT：更新资源（全量更新），幂等。</li><li>DELETE：删除资源，幂等。</li><li>HEAD：获取响应头，不返回响应体（用于检查资源是否存在、获取资源大小等）。</li><li>OPTIONS：获取服务器支持的请求方法。</li></ol></li><li><p><strong>常用状态码</strong></p><p>1xx（信息性状态码）：请求已接收，继续处理（如100 Continue）。</p><p>2xx（成功状态码）：请求正常处理完成（如200 OK，204 No Content）。</p><p>3xx（重定向状态码）：需要客户端进一步操作（如301 永久重定向，302 临时重定向，304 Not Modified 协商缓存命中）。</p><p>4xx（客户端错误）：请求存在错误（如400 Bad Request，401 未授权，403 禁止访问，404 资源不存在）。</p><p>5xx（服务器错误）：服务器处理请求出错（如500 内部服务器错误，502 网关错误，503 服务不可用，504 网关超时）。</p></li></ol><h3 id="2-4-HTTP版本演进"><a href="#2-4-HTTP版本演进" class="headerlink" title="2.4 HTTP版本演进"></a>2.4 HTTP版本演进</h3><ul><li><p>HTTP&#x2F;1.0：默认短连接，每次请求新建TCP连接，效率低；支持GET、POST、HEAD方法。</p></li><li><p>HTTP&#x2F;1.1：支持长连接（Keep-Alive），复用TCP连接；支持管线化（批量发送请求，无需等待响应）；增加PUT、DELETE等方法；支持Chunked Transfer Encoding（分块传输）。</p></li><li><p>HTTP&#x2F;2：基于二进制帧传输（而非文本）；支持多路复用（一个TCP连接同时处理多个请求-响应，避免队头阻塞）；支持头部压缩（减少头部传输体积）；支持服务器推送（主动向客户端推送资源）。</p></li><li><p>HTTP&#x2F;3：基于QUIC协议（UDP之上的可靠传输协议），解决TCP队头阻塞问题；支持0-RTT握手（快速建立连接）；更好的移动网络适配性。</p></li></ul><h2 id="3-HTTPS协议（超文本传输安全协议）"><a href="#3-HTTPS协议（超文本传输安全协议）" class="headerlink" title="3. HTTPS协议（超文本传输安全协议）"></a>3. HTTPS协议（超文本传输安全协议）</h2><h3 id="3-1-核心定位"><a href="#3-1-核心定位" class="headerlink" title="3.1 核心定位"></a>3.1 核心定位</h3><p>HTTPS是HTTP的安全版本，通过在HTTP和TCP之间加入TLS&#x2F;SSL加密层，实现数据传输的机密性、完整性和身份认证，解决HTTP明文传输的安全隐患。</p><h3 id="3-2-核心特点（对比HTTP）"><a href="#3-2-核心特点（对比HTTP）" class="headerlink" title="3.2 核心特点（对比HTTP）"></a>3.2 核心特点（对比HTTP）</h3><ul><li><p><strong>加密传输</strong>：数据通过对称加密传输，密钥通过非对称加密协商，避免数据被窃听。</p></li><li><p><strong>身份认证</strong>：通过数字证书验证服务器（或客户端）身份，避免中间人攻击。</p></li><li><p><strong>完整性校验</strong>：通过消息摘要算法（如SHA）验证数据完整性，避免数据被篡改。</p></li><li><p><strong>端口不同</strong>：HTTP默认端口80，HTTPS默认端口443。</p></li><li><p><strong>性能开销略高</strong>：TLS&#x2F;SSL握手过程需要额外的网络交互和加密运算。</p></li></ul><h3 id="3-3-核心原理（TLS-SSL握手过程）"><a href="#3-3-核心原理（TLS-SSL握手过程）" class="headerlink" title="3.3 核心原理（TLS&#x2F;SSL握手过程）"></a>3.3 核心原理（TLS&#x2F;SSL握手过程）</h3><ol><li><p>客户端 → 服务器：发送客户端支持的TLS版本、加密套件列表、随机数（Client Random）。</p></li><li><p>服务器 → 客户端：选择TLS版本和加密套件，发送服务器随机数（Server Random）、数字证书（含服务器公钥）。</p></li><li><p>客户端验证数字证书：通过CA（证书颁发机构）公钥验证证书合法性，确认服务器身份。</p></li><li><p>客户端 → 服务器：生成预主密钥（Pre-Master Secret），用服务器公钥加密后发送给服务器。</p></li><li><p>双方生成会话密钥：客户端和服务器分别用Client Random、Server Random、Pre-Master Secret，通过相同的算法生成会话密钥（对称加密密钥）。</p></li><li><p>客户端 → 服务器：发送加密的“握手完成”消息，验证会话密钥有效性。</p></li><li><p>服务器 → 客户端：发送加密的“握手完成”消息，验证会话密钥有效性。</p></li><li><p>握手完成：后续HTTP数据通过会话密钥进行对称加密传输。</p></li></ol><h3 id="3-4-数字证书作用"><a href="#3-4-数字证书作用" class="headerlink" title="3.4 数字证书作用"></a>3.4 数字证书作用</h3><p>数字证书是由CA颁发的电子文件，包含服务器公钥、服务器身份信息、CA签名等内容，用于证明服务器公钥的合法性和服务器身份的真实性，避免中间人替换服务器公钥的攻击。</p><h1 id="二、面试高频问题及解析"><a href="#二、面试高频问题及解析" class="headerlink" title="二、面试高频问题及解析"></a>二、面试高频问题及解析</h1><h2 id="1-TCP相关问题"><a href="#1-TCP相关问题" class="headerlink" title="1. TCP相关问题"></a>1. TCP相关问题</h2><h3 id="Q1：TCP为什么需要三次握手？两次握手可以吗？"><a href="#Q1：TCP为什么需要三次握手？两次握手可以吗？" class="headerlink" title="Q1：TCP为什么需要三次握手？两次握手可以吗？"></a>Q1：TCP为什么需要三次握手？两次握手可以吗？</h3><p>解析：</p><p>三次握手的核心目的是<strong>确保双方收发能力正常</strong>，并<strong>协商初始序列号（ISN）</strong>，避免因延迟的旧连接请求报文导致错误。</p><p>两次握手不可行，原因：</p><ul><li><p>无法确认客户端的接收能力：若服务器仅收到客户端的SYN报文就建立连接（两次握手），但客户端未收到服务器的SYN+ACK报文（如报文丢失），客户端不会认为连接建立，而服务器会等待客户端发送数据，造成资源浪费。</p></li><li><p>无法避免旧连接请求的干扰：若网络中存在延迟的旧SYN报文（如之前断开连接的残留报文），服务器收到后会误以为是新连接请求，两次握手后建立连接，向客户端发送数据，但客户端根本没有建立连接的需求，导致服务器资源浪费。三次握手的第三次ACK可让服务器确认客户端是“当前有效”的，避免该问题。</p></li></ul><h3 id="Q2：TCP四次挥手为什么需要四次？为什么不能三次？"><a href="#Q2：TCP四次挥手为什么需要四次？为什么不能三次？" class="headerlink" title="Q2：TCP四次挥手为什么需要四次？为什么不能三次？"></a>Q2：TCP四次挥手为什么需要四次？为什么不能三次？</h3><p>解析：</p><p>四次挥手的核心原因是<strong>TCP是双工通信</strong>，双方都需要独立关闭自己的发送通道，不能一次性同步关闭。</p><p>具体过程分析：</p><ul><li><p>第一次挥手：客户端告知服务器“我没有数据要发送了”（FIN&#x3D;1），但此时客户端仍可接收服务器的数据。</p></li><li><p>第二次挥手：服务器确认客户端的FIN请求（ACK&#x3D;1），但服务器可能还有未发送完的数据，需要继续发送，因此不能同时发送FIN报文。</p></li><li><p>第三次挥手：服务器发送完所有数据后，告知客户端“我也没有数据要发送了”（FIN&#x3D;1）。</p></li><li><p>第四次挥手：客户端确认服务器的FIN请求，连接关闭。</p></li></ul><p>不能三次的原因：服务器在第二次挥手时，无法确定自己是否还有数据要发送，若强制同时发送FIN（三次挥手），可能导致服务器未发送完的数据丢失。</p><h3 id="Q3：TCP的流量控制和拥塞控制有什么区别？分别如何实现？"><a href="#Q3：TCP的流量控制和拥塞控制有什么区别？分别如何实现？" class="headerlink" title="Q3：TCP的流量控制和拥塞控制有什么区别？分别如何实现？"></a>Q3：TCP的流量控制和拥塞控制有什么区别？分别如何实现？</h3><p>解析：</p><p>核心区别：<strong>控制对象不同</strong>——流量控制是控制“发送方与接收方之间”的速率匹配，避免接收方缓冲区溢出；拥塞控制是控制“发送方与整个网络之间”的速率匹配，避免网络拥塞。</p><p>实现方式：</p><ol><li><p>流量控制：通过<strong>滑动窗口机制</strong>实现。<br>接收方在ACK报文中携带自己的“接收窗口大小”（rwnd），告知发送方“我当前最多能接收多少字节的数据”。</p></li><li><p>发送方的发送窗口大小 ≤ 接收方的接收窗口大小，确保发送速率不超过接收方的处理能力。</p></li><li><p>若接收方缓冲区满，rwnd&#x3D;0，发送方停止发送，等待接收方发送新的ACK告知可用窗口。</p></li><li><p>拥塞控制：通过<strong>慢启动、拥塞避免、快速重传、快速恢复</strong>等算法实现。<br>慢启动：连接建立初期，发送窗口大小按指数增长（1→2→4→…），快速试探网络容量。</p></li><li><p>拥塞避免：当发送窗口大小达到慢启动阈值（ssthresh）后，改为线性增长（每次+1），避免网络拥塞。</p></li><li><p>快速重传：收到3个重复ACK时，直接重传对应报文段，无需等待超时，减少重传延迟。</p></li><li><p>快速恢复：快速重传后，将ssthresh设为当前拥塞窗口的一半，然后拥塞窗口从ssthresh开始线性增长，避免再次拥塞。</p></li></ol><h3 id="Q4：TCP和UDP的区别是什么？分别适用哪些场景？"><a href="#Q4：TCP和UDP的区别是什么？分别适用哪些场景？" class="headerlink" title="Q4：TCP和UDP的区别是什么？分别适用哪些场景？"></a>Q4：TCP和UDP的区别是什么？分别适用哪些场景？</h3><p>解析：</p><p>核心区别对比：</p><table><thead><tr><th>维度</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>连接性</td><td>面向连接</td><td>无连接</td></tr><tr><td>可靠性</td><td>可靠（无丢失、无重复、按序）</td><td>不可靠（可能丢失、乱序）</td></tr><tr><td>传输方式</td><td>字节流</td><td>数据报（独立报文）</td></tr><tr><td>头部开销</td><td>大（20-60字节）</td><td>小（8字节）</td></tr><tr><td>速度</td><td>慢（握手、重传等开销）</td><td>快（无额外开销）</td></tr><tr><td>拥塞控制</td><td>支持</td><td>不支持</td></tr><tr><td>适用场景</td><td>需要可靠传输的场景（文件传输、网页浏览、邮件发送、数据库交互）</td><td>对实时性要求高、可容忍少量丢失的场景（视频直播、语音通话、DNS查询、游戏）</td></tr></tbody></table><h2 id="2-HTTP相关问题"><a href="#2-HTTP相关问题" class="headerlink" title="2. HTTP相关问题"></a>2. HTTP相关问题</h2><h3 id="Q1：HTTP的无状态性是什么意思？如何解决？"><a href="#Q1：HTTP的无状态性是什么意思？如何解决？" class="headerlink" title="Q1：HTTP的无状态性是什么意思？如何解决？"></a>Q1：HTTP的无状态性是什么意思？如何解决？</h3><p>解析：</p><p>无状态性：服务器不会保存客户端的任何上下文信息，每次HTTP请求都是独立的，服务器无法通过请求直接识别客户端的身份或之前的交互状态。</p><p>解决方式：</p><ol><li><p><strong>Cookie</strong>：客户端第一次请求时，服务器生成包含用户信息的Cookie，通过响应头的Set-Cookie字段发送给客户端；客户端后续请求时，会通过请求头的Cookie字段携带该Cookie，服务器通过Cookie识别客户端。Cookie存储在客户端（浏览器），大小有限（约4KB），可设置过期时间。</p></li><li><p><strong>Session</strong>：客户端第一次请求时，服务器生成Session（存储用户信息），并将Session ID通过Cookie发送给客户端；客户端后续请求时，携带Session ID，服务器通过Session ID查找对应的Session。Session存储在服务器（内存、数据库等），安全性比Cookie高，可存储更多信息，但会占用服务器资源。</p></li><li><p><strong>Token</strong>：客户端登录成功后，服务器生成Token（如JWT）并返回给客户端；客户端后续请求时，通过请求头（如Authorization: Bearer Token）携带Token，服务器验证Token合法性。Token无需存储在服务器，可跨域使用，适合分布式系统、前后端分离项目。</p></li><li><p><strong>其他</strong>：URL重写（将Session ID拼接在URL后）、隐藏表单域等，安全性较低，现在较少使用。</p></li></ol><h3 id="Q2：HTTP的301和302状态码有什么区别？应用场景是什么？"><a href="#Q2：HTTP的301和302状态码有什么区别？应用场景是什么？" class="headerlink" title="Q2：HTTP的301和302状态码有什么区别？应用场景是什么？"></a>Q2：HTTP的301和302状态码有什么区别？应用场景是什么？</h3><p>解析：</p><p>两者均为重定向状态码，核心区别是<strong>重定向的永久性</strong>：</p><ol><li><p>301 Moved Permanently（永久重定向）：<br>含义：请求的资源已永久迁移到新的URL，后续所有请求都应直接访问新URL。</p></li><li><p>浏览器行为：会缓存新URL，后续再次请求原URL时，直接跳转到新URL，无需向服务器发送请求。</p></li><li><p>应用场景：域名更换、网站结构调整（资源永久迁移）、HTTP跳转HTTPS。</p></li><li><p>302 Found（临时重定向）：<br>含义：请求的资源暂时迁移到新的URL，后续请求仍可能访问原URL。</p></li><li><p>浏览器行为：默认不缓存新URL，每次请求原URL时，都会向服务器发送请求，由服务器告知新URL。</p></li><li><p>应用场景：网站维护时临时跳转至维护页面、A&#x2F;B测试时临时跳转不同页面、登录后跳转回原页面。</p></li></ol><p>补充：307 Temporary Redirect（临时重定向）与302类似，但要求客户端必须使用原请求方法（如原请求是POST，重定向后仍用POST）；302可能被浏览器默认转为GET请求。</p><h3 id="Q3：HTTP-1-1和HTTP-2的主要区别是什么？"><a href="#Q3：HTTP-1-1和HTTP-2的主要区别是什么？" class="headerlink" title="Q3：HTTP&#x2F;1.1和HTTP&#x2F;2的主要区别是什么？"></a>Q3：HTTP&#x2F;1.1和HTTP&#x2F;2的主要区别是什么？</h3><p>解析：</p><p>HTTP&#x2F;2在HTTP&#x2F;1.1的基础上做了大幅优化，核心区别如下：</p><ol><li><p><strong>传输方式</strong>：HTTP&#x2F;1.1基于文本传输，报文解析复杂，易出错；HTTP&#x2F;2基于二进制帧传输，将请求&#x2F;响应拆分为多个二进制帧（帧头部+数据），解析效率更高，错误率更低。</p></li><li><p><strong>多路复用</strong>：HTTP&#x2F;1.1的长连接虽可复用TCP连接，但同一连接内的请求需按顺序处理（管线化也无法彻底解决队头阻塞），一个请求阻塞会影响后续所有请求；HTTP&#x2F;2通过二进制帧的“流标识”（每个请求对应一个唯一流标识），实现同一TCP连接内同时处理多个请求-响应，彻底解决队头阻塞问题。</p></li><li><p><strong>头部压缩</strong>：HTTP&#x2F;1.1的请求头&#x2F;响应头每次都需完整传输，头部信息（如User-Agent、Host）重复率高，浪费带宽；HTTP&#x2F;2使用HPACK算法压缩头部，通过静态字典、动态字典缓存重复的头部字段，大幅减少头部传输体积。</p></li><li><p><strong>服务器推送</strong>：HTTP&#x2F;1.1只有客户端主动请求，服务器才能返回资源；HTTP&#x2F;2支持服务器推送，服务器可在客户端请求一个资源（如HTML页面）时，主动向客户端推送相关资源（如CSS、JS文件），减少客户端的请求次数。</p></li><li><p><strong>流量控制</strong>：HTTP&#x2F;2支持基于流的流量控制，可对每个流独立设置接收窗口，更精细地控制数据传输速率。</p></li></ol><h2 id="3-HTTPS相关问题"><a href="#3-HTTPS相关问题" class="headerlink" title="3. HTTPS相关问题"></a>3. HTTPS相关问题</h2><h3 id="Q1：HTTPS为什么比HTTP安全？HTTPS的加密过程是怎样的？"><a href="#Q1：HTTPS为什么比HTTP安全？HTTPS的加密过程是怎样的？" class="headerlink" title="Q1：HTTPS为什么比HTTP安全？HTTPS的加密过程是怎样的？"></a>Q1：HTTPS为什么比HTTP安全？HTTPS的加密过程是怎样的？</h3><p>解析：</p><p>HTTPS比HTTP安全的核心原因是<strong>加入了TLS&#x2F;SSL加密层</strong>，实现了三大安全目标：</p><ul><li><p>机密性：数据通过加密传输，只有发送方和接收方才能解密，避免被窃听。</p></li><li><p>完整性：通过消息摘要验证数据，确保数据在传输过程中未被篡改。</p></li><li><p>身份认证：通过数字证书验证服务器身份，避免中间人攻击。</p></li></ul><p>HTTPS的加密过程（TLS&#x2F;SSL握手+数据传输）：</p><ol><li><p><strong>握手阶段（协商密钥）</strong>：<br>客户端向服务器发送“客户端问候”：包含支持的TLS版本、加密套件列表、随机数A。</p></li><li><p>服务器向客户端发送“服务器问候”：包含选择的TLS版本、加密套件、随机数B、数字证书（含服务器公钥）。</p></li><li><p>客户端验证证书：用CA公钥解密证书中的CA签名，验证证书合法性（如证书是否过期、是否被篡改、域名是否匹配），确认服务器身份。</p></li><li><p>客户端生成预主密钥（Pre-Master Secret），用服务器公钥加密后发送给服务器。</p></li><li><p>客户端和服务器分别用随机数A、随机数B、预主密钥，通过相同的密钥派生算法生成会话密钥（对称加密密钥）。</p></li><li><p>双方互发“握手完成”消息，并用会话密钥加密，验证密钥协商成功。</p></li><li><p><strong>数据传输阶段</strong>：<br>后续的HTTP请求&#x2F;响应数据，都通过会话密钥进行对称加密传输（如AES算法）。</p></li><li><p>同时会对数据进行哈希运算生成消息摘要，附加在数据后，接收方通过验证摘要确认数据完整性。</p></li></ol><p>补充：为什么要结合对称加密和非对称加密？——非对称加密安全性高，但加密解密速度慢；对称加密速度快，但密钥协商过程不安全。HTTPS用非对称加密协商对称密钥，用对称加密传输数据，兼顾安全性和效率。</p><h3 id="Q2：HTTPS的数字证书是什么？作用是什么？如何验证证书的合法性？"><a href="#Q2：HTTPS的数字证书是什么？作用是什么？如何验证证书的合法性？" class="headerlink" title="Q2：HTTPS的数字证书是什么？作用是什么？如何验证证书的合法性？"></a>Q2：HTTPS的数字证书是什么？作用是什么？如何验证证书的合法性？</h3><p>解析：</p><ol><li><p>数字证书的定义：由权威的CA（证书颁发机构，如Verisign、Let’s Encrypt）颁发的电子文件，是服务器身份的“电子身份证”。</p></li><li><p>核心作用：身份认证：证明服务器的真实身份，避免客户端连接到伪造的服务器（中间人攻击）。</p></li><li><p>分发公钥：将服务器的公钥安全地分发给客户端，用于后续的密钥协商。</p></li><li><p>证书验证过程（客户端执行）：<br>验证证书签名：CA用自己的私钥对证书内容（服务器公钥、服务器域名、证书有效期等）进行签名；客户端用CA的公钥（内置在浏览器&#x2F;操作系统中）解密签名，得到证书内容的哈希值；同时客户端对收到的证书内容重新计算哈希值，对比两个哈希值，若一致则证书未被篡改。</p></li><li><p>验证证书有效期：检查证书的“生效时间”和“过期时间”，确认当前时间在有效期内。</p></li><li><p>验证域名匹配：检查证书中绑定的域名，是否与客户端请求的域名一致（避免证书被滥用）。</p></li><li><p>验证证书链：若证书是二级CA颁发的，需验证二级CA的证书是否由根CA颁发，直到验证到根CA（根CA证书是自签名的，默认信任），形成完整的证书链。</p></li></ol><h3 id="Q3：HTTP和HTTPS的区别是什么？"><a href="#Q3：HTTP和HTTPS的区别是什么？" class="headerlink" title="Q3：HTTP和HTTPS的区别是什么？"></a>Q3：HTTP和HTTPS的区别是什么？</h3><p>解析：</p><table><thead><tr><th>维度</th><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td>安全性</td><td>明文传输，不安全（易窃听、篡改、伪造）</td><td>TLS&#x2F;SSL加密，安全（机密性、完整性、身份认证）</td></tr><tr><td>端口</td><td>默认80</td><td>默认443</td></tr><tr><td>协议栈</td><td>应用层 → TCP</td><td>应用层 → TLS&#x2F;SSL → TCP</td></tr><tr><td>握手过程</td><td>无额外握手，直接发送HTTP请求</td><td>需先完成TLS&#x2F;SSL握手（协商密钥），再传输HTTP数据</td></tr><tr><td>性能开销</td><td>低（无加密、无额外握手）</td><td>高（TLS&#x2F;SSL握手、加密解密运算）</td></tr><tr><td>证书要求</td><td>无需证书</td><td>需向CA申请数字证书（免费&#x2F;付费）</td></tr><tr><td>适用场景</td><td>非敏感数据传输（如公开的静态网页）</td><td>敏感数据传输（如登录、支付、个人信息）</td></tr></tbody></table><h2 id="4-综合问题"><a href="#4-综合问题" class="headerlink" title="4. 综合问题"></a>4. 综合问题</h2><h3 id="Q1：从输入URL到页面加载完成，整个过程经历了哪些步骤？"><a href="#Q1：从输入URL到页面加载完成，整个过程经历了哪些步骤？" class="headerlink" title="Q1：从输入URL到页面加载完成，整个过程经历了哪些步骤？"></a>Q1：从输入URL到页面加载完成，整个过程经历了哪些步骤？</h3><p>解析：</p><ol><li><p><strong>URL解析</strong>：浏览器解析输入的URL，提取协议（HTTP&#x2F;HTTPS）、域名（如<a href="http://www.example.com)、端口(默认80/443%EF%BC%89%E3%80%81%E8%B7%AF%E5%BE%84%EF%BC%88%E5%A6%82/index.html%EF%BC%89%E7%AD%89%E4%BF%A1%E6%81%AF%E3%80%82">www.example.com）、端口（默认80/443）、路径（如/index.html）等信息。</a></p></li><li><p><strong>DNS解析</strong>：将域名转换为服务器的IP地址。</p><ol><li><p>浏览器先查询本地DNS缓存（如浏览器缓存、操作系统缓存），若命中则直接获取IP。</p></li><li><p>若本地缓存未命中，向本地DNS服务器（如路由器DNS、运营商DNS）发送查询请求，本地DNS服务器查询自身缓存或向上级DNS服务器（根服务器、顶级域服务器、权威DNS服务器）递归查询，最终返回IP地址。</p></li></ol></li><li><p><strong>建立连接</strong>：根据协议类型建立连接：</p><ol><li>HTTP：与服务器的IP:80端口建立TCP连接（三次握手）。</li><li>HTTPS：先与服务器的IP:443端口建立TCP连接，再完成TLS&#x2F;SSL握手（协商会话密钥）。</li></ol></li><li><p><strong>发送HTTP请求</strong>：浏览器通过建立的连接，向服务器发送HTTP请求报文（包含请求行、请求头、请求体）。</p></li><li><p><strong>服务器处理请求</strong>：服务器接收请求，解析请求内容，处理业务逻辑（如查询数据库、生成页面），生成HTTP响应报文（包含状态行、响应头、响应体）。</p></li><li><p><strong>服务器返回响应</strong>：服务器将响应报文通过连接发送给浏览器。</p></li><li><p><strong>浏览器接收响应并渲染页面</strong>：</p><ol><li><p>浏览器解析响应头，判断响应类型（如HTML、CSS、JS、图片）。</p></li><li><p>若响应是HTML，浏览器解析HTML生成DOM树，解析CSS生成CSSOM树，结合两者生成渲染树，然后进行布局（Layout）和绘制（Paint），最终在页面上显示内容。</p></li><li><p>过程中若遇到CSS、JS、图片等资源，会重复步骤2-6，请求并加载这些资源。</p></li></ol></li><li><p><strong>关闭连接</strong>：所有资源加载完成后，根据协议版本关闭连接（HTTP&#x2F;1.0直接关闭，HTTP&#x2F;1.1可复用连接或等待Keep-Alive超时后关闭）。</p></li></ol><h3 id="Q2：为什么HTTPS的TLS握手需要两次网络往返？如何优化？"><a href="#Q2：为什么HTTPS的TLS握手需要两次网络往返？如何优化？" class="headerlink" title="Q2：为什么HTTPS的TLS握手需要两次网络往返？如何优化？"></a>Q2：为什么HTTPS的TLS握手需要两次网络往返？如何优化？</h3><p>解析：</p><ol><li><p>TLS握手的网络往返次数：标准TLS 1.2握手需要2次网络往返（RTT）：<br>第一次RTT：客户端发送Client Hello → 服务器发送Server Hello + 证书 + Server Hello Done。</p></li><li><p>第二次RTT：客户端发送Client Key Exchange + Change Cipher Spec + Finished → 服务器发送Change Cipher Spec + Finished。</p></li><li><p>优化方式：</p><ol><li><p><strong>会话复用</strong>：会话ID复用：第一次握手后，服务器生成会话ID并存储会话密钥；客户端后续连接时，在Client Hello中携带会话ID，服务器通过会话ID查找会话密钥，直接跳过证书验证和密钥协商步骤，握手仅需1次RTT。</p></li><li><p><strong>会话票据复用</strong>：服务器生成会话票据（包含会话密钥，用服务器密钥加密）发送给客户端；客户端后续连接时携带会话票据，服务器解密票据获取会话密钥，无需存储会话信息，更适合分布式服务器。</p></li></ol></li><li><p><strong>TLS 1.3协议</strong>：TLS 1.3简化了握手过程，支持0-RTT或1-RTT握手：</p><ol><li><p>1-RTT握手：将Server Hello、证书、密钥协商信息合并发送，减少一次RTT，标准握手仅需1次RTT。</p></li><li><p>0-RTT握手：客户端可在第一次Client Hello中携带加密的应用数据（如HTTP请求），服务器验证后直接返回响应，无需额外RTT，大幅降低延迟（适合频繁访问的网站）。</p></li></ol></li><li><p><strong>证书优化</strong>：使用ECDSA证书（椭圆曲线加密，签名验证速度快）、减少证书链长度、启用OCSP Stapling（服务器提前获取证书状态信息，避免客户端单独查询OCSP服务器）。</p></li><li><p><strong>HTTP&#x2F;3协议</strong>：基于QUIC协议（UDP之上），QUIC的握手仅需0-RTT或1-RTT，同时集成了TLS 1.3加密，进一步降低HTTPS的连接延迟。</p></li></ol><h1 id="三、学习与面试建议"><a href="#三、学习与面试建议" class="headerlink" title="三、学习与面试建议"></a>三、学习与面试建议</h1><ol><li><p><strong>核心重点</strong>：优先掌握TCP三次握手&#x2F;四次挥手、可靠传输机制、HTTP报文结构&#x2F;状态码&#x2F;请求方法、HTTPS加密原理与证书机制，这些是面试高频考点。</p></li><li><p><strong>版本演进</strong>：理解HTTP&#x2F;1.1→HTTP&#x2F;2→HTTP&#x2F;3、TLS 1.2→TLS 1.3的演进逻辑（解决了什么问题、优化了什么），体现技术深度。</p></li><li><p><strong>实践结合</strong>：通过抓包工具（如Wireshark、Chrome开发者工具）分析真实的HTTP&#x2F;HTTPS请求报文、TCP连接过程，加深对理论知识的理解。</p></li><li><p><strong>问题延伸</strong>：回答面试题时，不仅要给出答案，还要解释“为什么”（如TCP三次握手的目的）、“有什么例外情况”（如三次握手失败怎么办）、“实际应用中的优化”（如HTTPS延迟优化），展现思考的全面性。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM学习笔记</title>
      <link href="/2025/12/09/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/12/09/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、JVM基础概念"><a href="#一、JVM基础概念" class="headerlink" title="一、JVM基础概念"></a>一、JVM基础概念</h1><h2 id="1-1-JVM定义与作用"><a href="#1-1-JVM定义与作用" class="headerlink" title="1.1 JVM定义与作用"></a>1.1 JVM定义与作用</h2><p>JVM（Java Virtual Machine，Java虚拟机）是运行Java字节码的虚拟计算机，它屏蔽了不同操作系统的底层差异，实现了“一次编写，到处运行”的Java核心特性。JVM的核心作用包括：加载解析字节码、管理内存、执行字节码、处理异常、垃圾回收等。</p><p>JVM与操作系统、硬件的关系：Java源码（.java）经编译器（javac）编译为字节码文件（.class），JVM负责将字节码翻译为本地机器指令（不同OS对应不同JVM实现，如HotSpot、J9等），最终由硬件执行。</p><h2 id="1-2-JVM架构核心组成"><a href="#1-2-JVM架构核心组成" class="headerlink" title="1.2 JVM架构核心组成"></a>1.2 JVM架构核心组成</h2><p>JVM架构主要分为五大核心模块，各模块协同工作完成字节码的执行与资源管理：</p><ol><li><p><strong>类加载器子系统（ClassLoader Subsystem）</strong>：负责加载.class文件到内存，完成“加载-链接-初始化”三个阶段。核心组件包括引导类加载器（Bootstrap ClassLoader，加载JDK核心类库，如rt.jar）、扩展类加载器（Extension ClassLoader，加载jre&#x2F;lib&#x2F;ext目录下的类库）、应用程序类加载器（Application ClassLoader，加载用户应用程序的类），以及自定义类加载器（继承ClassLoader实现）。</p></li><li><p><strong>运行时数据区（Runtime Data Area）</strong>：JVM在运行时分配的内存区域，也是面试核心考点，分为线程共享区和线程私有区：<br>线程共享区（所有线程共用，随JVM启动&#x2F;退出创建&#x2F;销毁）：方法区（Method Area，存储类元信息、常量、静态变量、即时编译后的代码等，JDK8后由元空间Metaspace实现，物理内存分配，无OOM上限）、堆（Heap，存储对象实例和数组，是垃圾回收的主要区域，分为年轻代[Eden区、Survivor0区、Survivor1区]和老年代）。</p></li><li><p>线程私有区（每个线程独立拥有，随线程创建&#x2F;销毁）：程序计数器（Program Counter Register，记录当前线程执行的字节码指令地址，无OOM）、虚拟机栈（VM Stack，存储方法调用的栈帧，每个栈帧包含局部变量表、操作数栈、动态链接、方法出口等，栈深度不足会抛出StackOverflowError，内存不足会抛出OutOfMemoryError）、本地方法栈（Native Method Stack，为本地方法[如Object.wait()]提供内存空间，与虚拟机栈功能类似，也可能抛出StackOverflowError和OutOfMemoryError）。</p></li><li><p><strong>执行引擎（Execution Engine）</strong>：将字节码翻译为本地机器指令并执行，核心组件包括解释器（Interpreter，逐行解释字节码，启动快但执行慢）、即时编译器（JIT Compiler，将频繁执行的热点代码编译为本地机器码，执行快但编译耗时），以及垃圾回收器（Garbage Collector，负责回收堆和方法区中无引用的对象，释放内存）。</p></li><li><p><strong>本地方法接口（Native Method Interface，JNI）</strong>：提供Java程序调用本地方法（C&#x2F;C++编写）的接口，用于与操作系统底层交互（如文件IO、网络通信等）。</p></li><li><p><strong>本地方法库（Native Method Library）</strong>：存储本地方法的实现，供JNI调用。</p></li></ol><h2 id="1-3-类加载机制"><a href="#1-3-类加载机制" class="headerlink" title="1.3 类加载机制"></a>1.3 类加载机制</h2><p>类加载机制是指将.class文件加载到内存，并对其进行验证、准备、解析、初始化，最终形成可使用的类对象的过程，核心遵循“双亲委派模型”：</p><ol><li><p><strong>加载（Loading）</strong>：通过类的全限定名（如java.lang.String）找到对应的.class文件，将其字节流读取到内存，生成一个代表该类的Class对象（存储在方法区）。</p></li><li><p><strong>链接（Linking）</strong>：分为三个阶段：</p><ul><li>验证（Verification）：检查.class文件的字节流是否符合JVM规范（如文件格式验证、元数据验证、字节码验证、符号引用验证），防止恶意字节码攻击</li><li>准备（Preparation）：为类的静态变量分配内存，并设置默认初始值（如int默认0、boolean默认false、引用类型默认null），不包含实例变量（实例变量在对象创建时分配在堆中）。</li><li>解析（Resolution）：将类中的符号引用（如类名、方法名、字段名）转换为直接引用（内存地址）。</li></ul></li><li><p><strong>初始化（Initialization）</strong>：执行类的静态代码块（static{}）和静态变量的显式赋值语句，初始化顺序遵循“父类优先于子类、静态变量按声明顺序、静态代码块按顺序执行”。</p></li></ol><p>双亲委派模型：当一个类加载器收到类加载请求时，首先委托给父类加载器加载，只有父类加载器无法加载（找不到对应的.class文件）时，才由当前类加载器自己加载。优势：避免类重复加载、保证核心类库的安全性（如防止用户自定义java.lang.String类覆盖核心类）。</p><h2 id="1-4-垃圾回收（GC）核心概念"><a href="#1-4-垃圾回收（GC）核心概念" class="headerlink" title="1.4 垃圾回收（GC）核心概念"></a>1.4 垃圾回收（GC）核心概念</h2><p>垃圾回收是指JVM自动回收堆和方法区中无引用对象的内存空间，核心解决“哪些对象需要回收”“何时回收”“如何回收”三个问题：</p><ol><li><strong>垃圾判定算法</strong>：<ul><li>引用计数法（Reference Counting）：为每个对象维护一个引用计数器，被引用时计数器+1，引用失效时-1，计数器为0则认为是垃圾。缺点：无法解决循环引用问题（如A引用B，B引用A，计数器均不为0，但实际无外部引用）。</li><li>可达性分析算法（Reachability Analysis）：JVM主流采用的算法，以“GC Roots”为起点，通过引用链遍历对象，无法到达的对象即为垃圾。GC Roots包括：虚拟机栈中局部变量表的引用对象、本地方法栈中本地方法的引用对象、方法区中静态变量和常量的引用对象、活跃线程的引用对象等。</li></ul></li><li><strong>引用类型（JDK1.2后）</strong>：<ul><li>强引用（Strong Reference）：如Object obj &#x3D; new Object()，只要强引用存在，对象不会被回收，即使OOM也不回收。</li><li>软引用（Soft Reference）：用于缓存场景，当内存不足时，JVM会回收软引用关联的对象。</li><li>弱引用（Weak Reference）：用于临时缓存，只要发生GC，无论内存是否充足，都会回收弱引用关联的对象。</li><li>虚引用（Phantom Reference）：无实际引用意义，仅用于监听对象被GC回收的事件，必须与ReferenceQueue配合使用。</li></ul></li><li><strong>GC算法</strong>：<ul><li>标记-清除算法（Mark-Sweep）：分为标记（标记垃圾对象）和清除（回收垃圾对象内存）两个阶段。优点：简单高效；缺点：产生内存碎片，后续大对象分配可能失败。</li><li>标记-复制算法（Mark-Copy）：将堆内存分为两块，只使用其中一块，GC时标记存活对象，复制到另一块未使用的内存，然后清空原使用块。优点：无内存碎片；缺点：内存利用率低（仅50%），适合年轻代（存活对象少）。</li><li>标记-整理算法（Mark-Compact）：标记存活对象后，将存活对象向内存一端移动，然后清空另一端的垃圾内存。优点：无内存碎片、内存利用率高；缺点：移动对象耗时，适合老年代（存活对象多）。</li><li>分代收集算法（Generational Collection）：结合上述算法的优势，根据对象存活周期将堆分为年轻代和老年代：年轻代采用标记-复制算法（存活对象少，复制成本低），老年代采用标记-清除或标记-整理算法（存活对象多，避免频繁复制）。</li></ul></li><li><strong>垃圾收集器</strong>：JVM的GC实现，不同收集器适用于不同场景，常见的有：Serial（串行收集器，单线程GC，适合单CPU环境）、ParNew（Serial的并行版本，多线程GC，年轻代专用）、Parallel Scavenge（并行收集器，注重吞吐量，年轻代专用）、Serial Old（Serial的老年代版本，串行标记-整理）、Parallel Old（Parallel Scavenge的老年代版本，并行标记-整理）、CMS（Concurrent Mark Sweep，并发标记清除，注重响应时间，老年代专用，并发GC，减少停顿）、G1（Garbage-First，区域化分代式收集器，兼顾吞吐量和响应时间，可管理整个堆）、ZGC&#x2F;Shenandoah（低延迟收集器，适合大内存、低停顿场景）。</li></ol><h1 id="二、JVM常用命令及示例"><a href="#二、JVM常用命令及示例" class="headerlink" title="二、JVM常用命令及示例"></a>二、JVM常用命令及示例</h1><p>JVM提供了一系列命令行工具（位于JDK的bin目录下），用于监控JVM运行状态、排查内存泄漏、分析GC情况等，是面试和工作中必备的工具，以下是常用命令及具体示例：</p><h2 id="2-1-jps：Java进程状态工具"><a href="#2-1-jps：Java进程状态工具" class="headerlink" title="2.1 jps：Java进程状态工具"></a>2.1 jps：Java进程状态工具</h2><p>作用：列出当前运行的Java进程（类似ps命令），输出进程ID（PID）和主类名。</p><p>语法：jps [选项]</p><p>常用选项：</p><ul><li><p>-l：输出主类的全限定名（若为Jar包，输出Jar包路径）。</p></li><li><p>-v：输出JVM启动参数。</p></li><li><p>-m：输出Java进程的启动参数（main方法的参数）。</p></li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有Java进程的PID和主类名</span></span><br><span class="line">jps</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">12345 HelloWorld</span><br><span class="line">67890 org.springframework.boot.loader.JarLauncher</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出PID、主类全限定名</span></span><br><span class="line">jps -l</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">12345 com.example.HelloWorld</span><br><span class="line">67890 /usr/local/app/spring-boot-app.jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出PID、主类名及JVM启动参数</span></span><br><span class="line">jps -v</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">12345 HelloWorld -Xms512m -Xmx1024m -XX:+UseG1GC</span><br><span class="line">67890 org.springframework.boot.loader.JarLauncher -Xms2g -Xmx2g -XX:MetaspaceSize=256m</span><br></pre></td></tr></table></figure><h2 id="2-2-jstat：JVM统计监控工具"><a href="#2-2-jstat：JVM统计监控工具" class="headerlink" title="2.2 jstat：JVM统计监控工具"></a>2.2 jstat：JVM统计监控工具</h2><p>作用：实时监控JVM的内存使用、GC情况、类加载情况等统计信息。</p><p>语法：jstat [选项] 进程ID [间隔时间(毫秒)] [查询次数]</p><p>常用选项：</p><ul><li><p>-class：监控类加载、卸载数量、总空间及类加载耗时。</p></li><li><p>-gc：监控堆内存各区域（Eden、Survivor、Old）的使用情况及GC次数、耗时。</p></li><li><p>-gcutil：监控堆内存各区域的使用率及GC统计信息（百分比形式，更直观）。</p></li><li><p>-gccapacity：监控堆内存各区域的最大容量、最小容量、当前容量。</p></li><li><p>-gcnew：监控年轻代GC情况。</p></li><li><p>-gcold：监控老年代GC情况。</p></li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监控进程12345的类加载情况，每1000毫秒查询一次，共查询5次</span></span><br><span class="line">jstat -class 12345 1000 5</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     Time   </span><br><span class="line">  1234   2345678      0        0     123.45</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控进程12345的GC情况，实时输出（无查询次数，需手动终止）</span></span><br><span class="line">jstat -gc 12345</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">10240.0 10240.0  0.0    0.0    61440.0  30720.0   122880.0    61440.0   24576.0 23040.0 3072.0 2816.0      5    0.025   1      0.050    0.075</span><br><span class="line"><span class="comment"># 说明：</span></span><br><span class="line"><span class="comment"># S0C/S1C：Survivor0/1区容量（KB）；S0U/S1U：Survivor0/1区已使用容量（KB）</span></span><br><span class="line"><span class="comment"># EC/EU：Eden区容量/已使用容量；OC/OU：老年代容量/已使用容量</span></span><br><span class="line"><span class="comment"># MC/MU：元空间容量/已使用容量；CCSC/CCSU：压缩类空间容量/已使用容量</span></span><br><span class="line"><span class="comment"># YGC/YGCT：年轻代GC次数/总耗时（秒）；FGC/FGCT：老年代GC次数/总耗时；GCT：GC总耗时</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控进程12345的堆内存使用率，每2000毫秒查询一次</span></span><br><span class="line">jstat -gcutil 12345 2000</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">  0.00   0.00  50.00  50.00  93.75  91.67      5    0.025   1      0.050    0.075</span><br><span class="line"><span class="comment"># 说明：各字段为对应区域的使用率（%）</span></span><br></pre></td></tr></table></figure><h2 id="2-3-jmap：JVM内存映像工具"><a href="#2-3-jmap：JVM内存映像工具" class="headerlink" title="2.3 jmap：JVM内存映像工具"></a>2.3 jmap：JVM内存映像工具</h2><p>作用：生成JVM的内存快照（heap dump），查看堆内存中对象的分布情况，排查内存泄漏。</p><p>语法：jmap [选项] 进程ID</p><p>常用选项：</p><ul><li><p>-heap：查看堆内存的详细配置（如分代大小、GC算法、收集器等）及使用情况。</p></li><li><p>-histo：查看堆内存中对象的统计信息（类名、实例数量、占用内存大小）。</p></li><li><p>-dump:format&#x3D;b,file&#x3D;文件名.hprof：生成堆内存快照（二进制格式），后续可通过jhat或VisualVM分析。</p></li><li><p>-permstat（JDK7及之前）&#x2F; -clstats（JDK8+）：查看永久代&#x2F;元空间的类加载器统计信息。</p></li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看进程12345的堆内存配置及使用情况</span></span><br><span class="line">jmap -heap 12345</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">Attaching to process ID 12345, please <span class="built_in">wait</span>...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 17.0.6+10-LTS</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Garbage-First (G1) GC with 4 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 40</span><br><span class="line">   MaxHeapFreeRatio         = 70</span><br><span class="line">   MaxHeapSize              = 1073741824 (1024.0MB)</span><br><span class="line">   NewSize                  = 357564416 (341.0MB)</span><br><span class="line">   MaxNewSize               = 644245094 (614.4MB)</span><br><span class="line">   OldSize                  = 716208128 (683.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 268435456 (256.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 1073741824 (1024.0MB)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程12345的堆内存对象统计，按内存占用降序排列</span></span><br><span class="line">jmap -histo 12345 | <span class="built_in">sort</span> -k 3 -n -r | <span class="built_in">head</span> -10</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line"> num     <span class="comment">#instances         #bytes  class name (module)</span></span><br><span class="line">-------------------------------------------------------</span><br><span class="line">   1:          1234        567890  java.lang.String (java.base)</span><br><span class="line">   2:           456        234567  java.util.HashMap<span class="variable">$Node</span> (java.base)</span><br><span class="line">   3:           789        198765  com.example.User (unnamed module @0x12345678)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成进程12345的堆内存快照，保存为heap_dump.hprof</span></span><br><span class="line">jmap -dump:format=b,file=heap_dump.hprof 12345</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">Dumping heap to /home/user/heap_dump.hprof ...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure><h2 id="2-4-jhat：JVM堆快照分析工具"><a href="#2-4-jhat：JVM堆快照分析工具" class="headerlink" title="2.4 jhat：JVM堆快照分析工具"></a>2.4 jhat：JVM堆快照分析工具</h2><p>作用：分析jmap生成的堆内存快照（.hprof文件），提供Web界面查看对象分布、引用关系等，排查内存泄漏。</p><p>语法：jhat [选项] 堆快照文件名.hprof</p><p>常用选项：</p><ul><li><p>-port：指定Web服务端口（默认7000）。</p></li><li><p>-exclude：排除指定包名的类，减少分析数据量。</p></li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分析heap_dump.hprof文件，启动Web服务，端口7001</span></span><br><span class="line">jhat -port 7001 heap_dump.hprof</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">Reading from heap_dump.hprof...</span><br><span class="line">Dump file created Mon Dec 09 10:00:00 CST 2025</span><br><span class="line">Snapshot <span class="built_in">read</span>, resolving...</span><br><span class="line">Resolving 123456 objects...</span><br><span class="line">Chasing references, expect 24 dots........................</span><br><span class="line">Eliminating duplicate references........................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 7001</span><br><span class="line">Server is ready.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问Web界面：http://localhost:7001，可查看：</span></span><br><span class="line"><span class="comment"># 1. 所有类的统计信息（实例数、内存占用）</span></span><br><span class="line"><span class="comment"># 2. 对象的引用关系（反向引用，找到内存泄漏的根源）</span></span><br><span class="line"><span class="comment"># 3. 堆内存的整体使用情况</span></span><br></pre></td></tr></table></figure><h2 id="2-5-jstack：JVM线程快照工具"><a href="#2-5-jstack：JVM线程快照工具" class="headerlink" title="2.5 jstack：JVM线程快照工具"></a>2.5 jstack：JVM线程快照工具</h2><p>作用：生成JVM的线程快照（线程堆栈），查看线程的运行状态（如RUNNABLE、BLOCKED、WAITING）、调用栈信息，排查线程死锁、线程阻塞、CPU占用过高等问题。</p><p>语法：jstack [选项] 进程ID</p><p>常用选项：</p><ul><li><p>-F：强制生成线程快照（当进程无响应时使用）。</p></li><li><p>-l：显示线程的锁信息（如持有锁、等待锁的情况）。</p></li><li><p>-m：显示线程的本地方法调用栈（结合本地方法库分析）。</p></li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成进程12345的线程快照，包含锁信息，保存到thread_dump.txt</span></span><br><span class="line">jstack -l 12345 &gt; thread_dump.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看线程快照中的死锁信息（jstack会自动检测死锁并标注）</span></span><br><span class="line">grep -A 20 <span class="string">&quot;Deadlock detected&quot;</span> thread_dump.txt</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span>:</span><br><span class="line">  waiting <span class="keyword">for</span> ownable synchronizer 0x000000076ab04000, (a java.util.concurrent.locks.ReentrantLock<span class="variable">$NonfairSync</span>)</span><br><span class="line">  <span class="built_in">which</span> is held by <span class="string">&quot;Thread-0&quot;</span></span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span>:</span><br><span class="line">  waiting <span class="keyword">for</span> ownable synchronizer 0x000000076ab04020, (a java.util.concurrent.locks.ReentrantLock<span class="variable">$NonfairSync</span>)</span><br><span class="line">  <span class="built_in">which</span> is held by <span class="string">&quot;Thread-1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定线程的运行状态（如查找BLOCKED状态的线程）</span></span><br><span class="line">grep <span class="string">&quot;java.lang.Thread.State: BLOCKED&quot;</span> thread_dump.txt -B 5 -A 5</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line"><span class="string">&quot;Thread-2&quot;</span> <span class="comment">#10 prio=5 os_prio=0 cpu=0.00ms elapsed=123.45s tid=0x00007f89a0002000 nid=0x2468 waiting for monitor entry [0x00007f8998f7e000]</span></span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at com.example.Service.doSomething(Service.java:45)</span><br><span class="line">        - waiting to lock &lt;0x000000076ab06000&gt; (a com.example.Service)</span><br><span class="line">        at com.example.Thread2.run(Thread2.java:20)</span><br></pre></td></tr></table></figure><h2 id="2-6-jinfo：JVM配置信息工具"><a href="#2-6-jinfo：JVM配置信息工具" class="headerlink" title="2.6 jinfo：JVM配置信息工具"></a>2.6 jinfo：JVM配置信息工具</h2><p>作用：查看或修改JVM的运行时配置参数（如-Xms、-Xmx、-XX:XXX等）。</p><p>语法：jinfo [选项] 进程ID</p><p>常用选项：</p><ul><li><p>-flags：查看JVM的所有启动参数（包括默认参数和用户指定参数）。</p></li><li><p>-sysprops：查看Java系统属性（System.getProperties()的内容）。</p></li><li><p>-flag 参数名：查看指定参数的值（如-flag MaxHeapSize）。</p></li><li><p>-flag [+&#x2F;-]参数名：动态开启&#x2F;关闭指定的布尔型参数（如-flag +UseG1GC）。</p></li><li><p>-flag 参数名&#x3D;值：动态修改指定参数的值（仅部分参数支持，如-flag HeapDumpPath&#x3D;&#x2F;tmp&#x2F;）。</p></li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看进程12345的所有JVM启动参数</span></span><br><span class="line">jinfo -flags 12345</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">Attaching to process ID 12345, please <span class="built_in">wait</span>...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 17.0.6+10-LTS</span><br><span class="line">Non-default VM flags: -XX:CICompilerCount=4 -XX:InitialHeapSize=536870912 -XX:MaxHeapSize=1073741824 -XX:MetaspaceSize=268435456 -XX:MaxMetaspaceSize=1073741824 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC</span><br><span class="line">Command line:  -Xms512m -Xmx1024m -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=1024m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程12345的Java系统属性</span></span><br><span class="line">jinfo -sysprops 12345</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">java.runtime.name=OpenJDK Runtime Environment</span><br><span class="line">java.vm.version=17.0.6+10-LTS</span><br><span class="line">java.home=/usr/local/jdk17</span><br><span class="line">java.class.path=./target/classes:./lib/spring-boot-starter.jar</span><br><span class="line">user.dir=/home/user/project</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程12345的MaxHeapSize参数值</span></span><br><span class="line">jinfo -flag MaxHeapSize 12345</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">-XX:MaxHeapSize=1073741824</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态开启进程12345的HeapDumpOnOutOfMemoryError参数（OOM时自动生成堆快照）</span></span><br><span class="line">jinfo -flag +HeapDumpOnOutOfMemoryError 12345</span><br></pre></td></tr></table></figure><h1 id="三、JVM相关面试题"><a href="#三、JVM相关面试题" class="headerlink" title="三、JVM相关面试题"></a>三、JVM相关面试题</h1><h2 id="3-1-基础概念类"><a href="#3-1-基础概念类" class="headerlink" title="3.1 基础概念类"></a>3.1 基础概念类</h2><ol><li><p>**问题1：什么是JVM？JVM的核心作用是什么？**答：JVM（Java Virtual Machine）是运行Java字节码的虚拟计算机，它屏蔽了不同操作系统的底层差异，实现“一次编写，到处运行”。核心作用包括：加载解析.class文件、管理运行时内存（堆、栈、方法区等）、执行字节码（通过解释器或JIT编译器）、垃圾回收（自动回收无引用对象内存）、处理异常、提供本地方法调用接口（JNI）等。</p></li><li><p>**问题2：JVM的核心架构由哪些部分组成？各部分的作用是什么？**答：JVM核心架构包括五大模块：类加载器子系统：负责将.class文件加载到内存，完成加载、链接、初始化过程，遵循双亲委派模型。</p><ol><li><p>运行时数据区：存储JVM运行时的各种数据，分为线程共享区（方法区、堆）和线程私有区（程序计数器、虚拟机栈、本地方法栈）。</p></li><li><p>执行引擎：将字节码翻译为本地机器指令并执行，包含解释器、JIT编译器和垃圾回收器。</p></li><li><p>本地方法接口（JNI）：提供Java程序调用本地方法（C&#x2F;C++编写）的接口，用于与操作系统交互。</p></li><li><p>本地方法库：存储本地方法的实现，供JNI调用。</p></li></ol></li><li><p>**问题3：什么是双亲委派模型？它的优势是什么？如何打破双亲委派模型？**答：双亲委派模型是类加载器的加载规则：当一个类加载器收到加载请求时，首先委托给父类加载器加载，只有父类加载器无法加载（找不到.class文件）时，才由当前类加载器自己加载。<br>优势：① 避免类重复加载（同一类被不同类加载器加载会视为不同类）；② 保证核心类库的安全性（防止用户自定义核心类，如java.lang.String，覆盖JDK原生类）。<br>打破双亲委派模型的方式：① 重写ClassLoader的loadClass()方法（不遵循委托逻辑）；② 使用线程上下文类加载器（Thread.getContextClassLoader()），如JDBC加载驱动时，打破了核心类加载器无法加载用户应用类的限制。</p></li><li><p>**问题4：JVM运行时数据区分为哪些部分？各部分的作用是什么？可能发生哪些OOM？**答：运行时数据区分为线程共享区和线程私有区：</p><ol><li>线程共享区（所有线程共用）：<br>① 方法区（元空间，JDK8+）：存储类元信息、常量、静态变量、JIT编译后的代码等。可能发生OOM：元空间内存不足（如大量动态生成类，未及时卸载）。<br>② 堆：存储对象实例和数组，是GC主要区域。可能发生OOM：堆内存不足（如创建大量对象，GC无法回收，如内存泄漏）。</li><li>线程私有区（每个线程独立拥有）：<br>① 程序计数器：记录当前线程执行的字节码指令地址，无OOM（内存占用极小，JVM直接管理）。<br>② 虚拟机栈：存储方法调用的栈帧（局部变量表、操作数栈等）。可能发生：StackOverflowError（栈深度不足，如递归调用过深）、OutOfMemoryError（栈内存不足，如创建大量线程，每个线程栈占用过多内存）。<br>③ 本地方法栈：为本地方法提供内存空间，与虚拟机栈类似，可能发生StackOverflowError和OutOfMemoryError。</li></ol></li></ol><h2 id="3-2-垃圾回收类"><a href="#3-2-垃圾回收类" class="headerlink" title="3.2 垃圾回收类"></a>3.2 垃圾回收类</h2><ol><li><p>**问题1：JVM如何判断一个对象是垃圾？有哪些垃圾判定算法？**答：JVM判断对象为垃圾的核心标准是“对象无引用可达”。常用垃圾判定算法有两种：<br>① 引用计数法：为每个对象维护引用计数器，被引用时+1，引用失效时-1，计数器为0则为垃圾。缺点：无法解决循环引用问题（如A引用B，B引用A，计数器均不为0，但无外部引用）。<br>② 可达性分析算法：JVM主流采用，以GC Roots为起点，通过引用链遍历对象，无法到达的对象即为垃圾。GC Roots包括：虚拟机栈局部变量表的引用对象、本地方法栈本地方法的引用对象、方法区静态变量和常量的引用对象、活跃线程的引用对象等。</p></li><li><p>**问题2：Java中的引用类型有哪些？各有什么特点？**答：JDK1.2后将引用分为四类，优先级从高到低：<br>① 强引用：如Object obj &#x3D; new Object()，只要强引用存在，对象不会被GC回收，即使OOM也不回收。<br>② 软引用：用于缓存场景（如图片缓存），当内存不足时，JVM会回收软引用关联的对象。通过SoftReference类实现。<br>③ 弱引用：用于临时缓存，只要发生GC，无论内存是否充足，都会回收弱引用关联的对象。通过WeakReference类实现。<br>④ 虚引用：无实际引用意义，仅用于监听对象被GC回收的事件，必须与ReferenceQueue配合使用。通过PhantomReference类实现。</p></li><li><p>**问题3：常见的GC算法有哪些？各有什么优缺点？适用场景是什么？**答：常见GC算法包括：<br>① 标记-清除算法（Mark-Sweep）：<br>优点：简单高效，无需移动对象；<br>缺点：产生内存碎片，后续大对象分配可能失败；<br>适用场景：无（仅作为基础算法，后续算法基于其优化）。<br>② 标记-复制算法（Mark-Copy）：<br>优点：无内存碎片，实现简单；<br>缺点：内存利用率低（仅50%），复制对象耗时；<br>适用场景：年轻代（存活对象少，复制成本低）。<br>③ 标记-整理算法（Mark-Compact）：<br>优点：无内存碎片，内存利用率高；<br>缺点：移动对象耗时，需要暂停线程（STW）；<br>适用场景：老年代（存活对象多，避免频繁复制）。<br>④ 分代收集算法（Generational Collection）：<br>优点：结合上述算法优势，根据对象存活周期分代处理，兼顾效率和内存利用率；<br>缺点：实现复杂；<br>适用场景：所有主流JVM（如HotSpot），是目前最常用的GC算法。</p></li><li><p>**问题4：常见的垃圾收集器有哪些？各有什么特点？适用场景是什么？**答：常见垃圾收集器及特点、适用场景：<br>① Serial（串行收集器）：<br>特点：单线程GC，STW时间长，实现简单，内存占用少；<br>适用场景：单CPU环境、小型应用（如桌面应用）。<br>② ParNew（并行收集器）：<br>特点：Serial的并行版本，多线程GC，年轻代专用，可与CMS配合使用；<br>适用场景：多CPU环境，需要减少年轻代GC停顿时间的应用。<br>③ Parallel Scavenge（并行收集器）：<br>特点：多线程GC，年轻代专用，注重吞吐量（吞吐量&#x3D;运行用户代码时间&#x2F;(运行用户代码时间+GC时间)），可自动调节堆大小和GC频率；<br>适用场景：后台计算类应用（如大数据处理），对吞吐量要求高，对响应时间要求低。<br>④ CMS（Concurrent Mark Sweep）：<br>特点：并发GC，老年代专用，注重响应时间（STW时间短），采用标记-清除算法；<br>缺点：CPU占用高，产生内存碎片，无法处理浮动垃圾（GC过程中产生的新垃圾）；<br>适用场景：Web应用、分布式服务等对响应时间要求高的应用。<br>⑤ G1（Garbage-First）：<br>特点：区域化分代式收集器，可管理整个堆，兼顾吞吐量和响应时间，采用标记-整理算法（无内存碎片），可预测GC停顿时间；<br>适用场景：大内存应用（如堆内存10GB+），对响应时间和吞吐量均有要求的应用（如电商系统）。<br>⑥ ZGC&#x2F;Shenandoah：<br>特点：低延迟收集器，STW时间极短（毫秒级以下），支持大内存（如百GB级堆内存）；<br>适用场景：金融、电信等对延迟要求极高的核心业务系统。</p></li><li><p>**问题5：什么是STW（Stop The World）？如何减少STW对应用的影响？**答：STW是指GC过程中，JVM暂停所有用户线程的执行，只执行GC线程，目的是避免GC过程中对象引用关系发生变化，保证GC的正确性。STW会导致应用响应延迟，影响用户体验。<br>减少STW影响的方式：<br>① 选择合适的垃圾收集器（如CMS、G1、ZGC等低延迟收集器）；<br>② 优化JVM参数（如调整堆大小、分代比例、GC触发阈值等，减少GC频率和每次GC的停顿时间）；<br>③ 减少大对象的创建（大对象直接进入老年代，容易触发老年代GC，STW时间长）；<br>④ 避免内存泄漏（内存泄漏会导致堆内存不足，频繁触发GC，增加STW次数）；<br>⑤ 使用并发GC（如CMS、G1的并发标记阶段，不暂停用户线程）。</p></li></ol><h2 id="3-3-性能调优与问题排查类"><a href="#3-3-性能调优与问题排查类" class="headerlink" title="3.3 性能调优与问题排查类"></a>3.3 性能调优与问题排查类</h2><ol><li>**问题1：什么是内存泄漏？如何排查JVM内存泄漏？**答：内存泄漏是指对象不再被应用程序使用，但由于存在无效引用，导致GC无法回收该对象，长期积累会导致堆内存不足，最终触发OOM。<br>排查内存泄漏的步骤：<br>① 监控JVM内存使用：通过jstat -gcutil命令实时监控堆内存使用率，若老年代使用率持续上升，可能存在内存泄漏。<br>② 生成堆内存快照：通过jmap -dump:format&#x3D;b,file&#x3D;xxx.hprof命令生成堆快照。<br>③ 分析堆快照：使用jhat或VisualVM工具分析堆快照，查看：</li></ol><ul><li>哪些对象占用内存过多（实例数多、内存占比高）；</li><li>这些对象的引用链（找到持有这些对象的无效引用，即内存泄漏的根源，如未关闭的连接、静态集合存储大量对象未清理等）。<br>④ 验证问题：根据分析结果，检查代码中对应的引用逻辑，修复无效引用（如关闭连接、清理静态集合），重新部署后监控内存使用，确认泄漏问题解决。</li></ul><ol start="2"><li><p>**问题2：如何排查JVM线程死锁问题？**答：排查线程死锁的步骤：<br>① 识别死锁现象：应用响应缓慢、CPU利用率低、线程无法正常执行任务。<br>② 生成线程快照：通过jstack -l 进程ID命令生成线程快照（-l选项显示锁信息）。<br>③ 分析线程快照：jstack会自动检测死锁并标注“Deadlock detected”，查看死锁线程的信息：</p><ul><li><p>每个死锁线程等待的锁（ownable synchronizer）；</p></li><li><p>每个死锁线程持有的锁（被其他线程等待的锁）；</p></li><li><p>线程的调用栈（找到死锁发生的代码位置）。</p></li></ul><p>④ 修复死锁：根据分析结果，调整代码中的锁获取顺序（如所有线程按相同顺序获取多个锁）、减少锁的持有时间、避免嵌套锁等，重新部署后验证问题解决。</p></li><li><p>**问题3：JVM常用的调优参数有哪些？请举例说明。**答：JVM调优参数主要分为三类：堆内存参数、GC参数、其他参数，常用示例：<br>① 堆内存参数：<br>-Xms：初始堆内存大小（如-Xms512m，JDK1.8后默认初始堆为物理内存的1&#x2F;64）；<br>-Xmx：最大堆内存大小（如-Xmx1024m，建议与-Xms设置为相同值，避免频繁调整堆大小）；<br>-Xmn：年轻代内存大小（如-Xmn384m，年轻代&#x3D;Eden+Survivor，默认年轻代占堆的1&#x2F;3）；<br>-XX:SurvivorRatio：Eden区与Survivor区的比例（如-XX:SurvivorRatio&#x3D;8，Eden:S0:S1&#x3D;8:1:1，默认8）；<br>-XX:MetaspaceSize：元空间初始大小（如-XX:MetaspaceSize&#x3D;256m，JDK8+，替代永久代）；<br>-XX:MaxMetaspaceSize：元空间最大大小（如-XX:MaxMetaspaceSize&#x3D;1024m，默认无上限，物理内存限制）。<br>② GC参数：<br>-XX:+UseG1GC：使用G1收集器（JDK9后默认）；<br>-XX:+UseConcMarkSweepGC：使用CMS收集器；<br>-XX:+UseParallelGC：使用Parallel Scavenge收集器（JDK8默认）；<br>-XX:MaxGCPauseMillis：G1收集器的最大GC停顿时间（如-XX:MaxGCPauseMillis&#x3D;200，单位毫秒）；<br>-XX:+HeapDumpOnOutOfMemoryError：OOM时自动生成堆快照（如-XX:HeapDumpPath&#x3D;&#x2F;tmp&#x2F;heap_dump.hprof指定保存路径）；<br>-XX:ParallelGCThreads：并行GC的线程数（如-XX:ParallelGCThreads&#x3D;4，默认与CPU核心数相同）。<br>③ 其他参数：<br>-XX:+PrintGCDetails：打印GC详细日志；<br>-XX:+PrintGCTimeStamps：打印GC发生的时间戳；<br>-Xss：每个线程的栈大小（如-Xss1m，默认1m，影响线程数量，栈越大可创建的线程越少）。</p></li><li><p>**问题4：如何分析JVM GC日志？*<em>答：分析GC日志的步骤：<br>① 开启GC日志：通过JVM参数开启，如-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xlog:gc</em>:file&#x3D;gc.log:time,level,tags:filecount&#x3D;5,filesize&#x3D;100m（JDK9+），将GC日志输出到文件。<br>② 关键日志字段解读：</p><ul><li><p>日志时间戳：如“2.345”表示JVM启动后2.345秒发生GC；</p></li><li><p>GC类型：Young GC（年轻代GC，如YGC、ParNew）、Full GC（老年代GC，如FGC、CMS）；</p></li><li><p>内存变化：如“Eden Space: 51200K-&gt;0K(61440K)”表示Eden区从51200K使用量变为0K（GC回收），总容量61440K；</p></li><li><p>GC耗时：如“0.0250000 secs”表示GC耗时25毫秒；</p></li><li><p>堆内存整体使用：如“Heap after GC: 61440K-&gt;30720K(102400K)”表示GC后堆内存使用量从61440K变为30720K，总容量102400K。</p></li></ul><p>③ 分析重点：</p><ul><li><p>GC频率：年轻代GC是否过于频繁（如每秒多次，可能是年轻代过小或创建对象过快）；</p></li><li><p>GC耗时：单次GC停顿时间是否过长（如Full GC耗时超过1秒，影响响应时间）；</p></li><li><p>内存变化：老年代使用量是否持续上升（可能存在内存泄漏）；</p></li><li><p>Full GC次数：Full GC耗时远大于Young GC，应尽量减少Full GC次数（如通过调整老年代大小、优化对象生命周期）。<br>④ 工具辅助：使用GC Easy、GCEasy、VisualVM等工具导入GC日志，自动生成分析报告（如GC频率、耗时统计、内存泄漏预警等），提升分析效率。</p></li></ul></li></ol><h2 id="3-4-进阶类"><a href="#3-4-进阶类" class="headerlink" title="3.4 进阶类"></a>3.4 进阶类</h2><ol><li><p>**问题1：什么是JIT编译器？它的作用是什么？**答：JIT（Just-In-Time）编译器是JVM执行引擎的组成部分，作用是将频繁执行的“热点代码”（如循环、频繁调用的方法）从字节码编译为本地机器码，从而提升代码执行效率。<br>JVM的执行方式：初始时通过解释器逐行解释字节码（启动快，执行慢），当JVM检测到某段代码被频繁执行（达到热点阈值），则触发JIT编译，将其编译为本地机器码，后续执行该代码时直接运行机器码（执行快，编译耗时）。<br>热点代码的判定：通过“采样计数器”（统计代码被调用的次数）和“循环计数器”（统计循环执行的次数）判定，当达到预设阈值（如方法被调用10000次，循环执行1000次），则标记为热点代码。</p></li><li><p>**问题2：JDK8中JVM的内存模型有哪些变化？为什么要做这些变化？**答：JDK8中JVM内存模型的核心变化是：将永久代（PermGen）替换为元空间（Metaspace）。<br>变化细节：</p></li></ol><ul><li>永久代（JDK7及之前）：存储类元信息、常量、静态变量等，内存分配在JVM堆中，有固定大小限制（通过-XX:PermSize和-XX:MaxPermSize指定），容易发生PermGen OOM（如动态生成大量类时）。</li><li>元空间（JDK8+）：存储类元信息等，内存分配在本地物理内存（而非JVM堆），默认无上限（受物理内存限制），可通过-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定初始和最大大小。<br>变化原因：<br>① 永久代大小难以确定（不同应用的类数量差异大，容易设置过小导致OOM，设置过大浪费内存）；<br>② 永久代的垃圾回收效率低（类元信息的回收条件苛刻，容易积累导致内存泄漏）；<br>③ 元空间使用本地内存，避免了永久代的内存限制，提升了JVM的稳定性和可扩展性；<br>④ 契合JDK的模块化发展（如Jigsaw项目），更好地支持类的动态加载和卸载。</li></ul><ol start="3"><li>**问题3：什么是逃逸分析？JVM如何利用逃逸分析优化性能？**答：逃逸分析是JVM的一种静态分析技术，用于分析对象的引用范围（即对象是否会“逃逸”出当前方法或线程）。<br>对象逃逸的情况：</li></ol><ul><li>方法逃逸：对象被返回给方法的调用者（如return obj）；</li><li>线程逃逸：对象被存储到线程共享的变量中（如静态变量、堆中的对象字段）。<br>JVM利用逃逸分析的优化手段：<br>① 栈上分配（Stack Allocation）：若对象未逃逸（仅在当前方法内使用），则将对象分配在虚拟机栈的局部变量表中，而非堆中。栈上分配的</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql学习笔记</title>
      <link href="/2025/12/09/MySql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/12/09/MySql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、MySql学习笔记"><a href="#一、MySql学习笔记" class="headerlink" title="一、MySql学习笔记"></a>一、MySql学习笔记</h1><h2 id="1-数据库基础概念"><a href="#1-数据库基础概念" class="headerlink" title="1. 数据库基础概念"></a>1. 数据库基础概念</h2><ul><li><p><strong>数据库（DB）</strong>：存储数据的仓库，按一定格式组织和存储数据，便于管理和访问。</p></li><li><p><strong>数据库管理系统（DBMS）</strong>：管理数据库的软件，如MySQL、Oracle、SQL Server等，提供数据定义、查询、更新、控制等功能。</p></li><li><p><strong>SQL（结构化查询语言）</strong>：用于与DBMS交互的标准语言，分为DQL（数据查询）、DML（数据操作）、DDL（数据定义）、DCL（数据控制）。</p></li><li><p><strong>关系型数据库（RDBMS）</strong>：基于关系模型（二维表结构）的数据库，数据之间存在关联关系，支持ACID特性，MySQL是典型的RDBMS。</p></li></ul><h2 id="2-MySQL核心特性"><a href="#2-MySQL核心特性" class="headerlink" title="2. MySQL核心特性"></a>2. MySQL核心特性</h2><ul><li><p><strong>ACID特性</strong>：事务的四大特性，保证数据的安全性和一致性。<br>原子性（Atomicity）：事务是不可分割的最小单位，要么全部执行，要么全部不执行。</p></li><li><p>一致性（Consistency）：事务执行前后，数据库的完整性约束不被破坏（如主键唯一、外键关联正常）。</p></li><li><p>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不会被其他事务干扰。</p></li><li><p>持久性（Durability）：事务一旦提交，其对数据库的修改会永久保存，即使数据库崩溃也不会丢失。</p></li></ul><p><strong>存储引擎</strong>：MySQL的核心组件，负责数据的存储和读取，不同引擎有不同特性，常用的有InnoDB、MyISAM。<br>        InnoDB：默认存储引擎，支持事务、行级锁、外键，适合高并发、数据一致性要求高的场景（如电商订单、金融数据）。</p><p>MyISAM：不支持事务和行级锁，支持表级锁，查询速度快，适合读多写少的场景（如博客文章、静态数据）。</p><p><strong>索引</strong>：帮助MySQL高效查询数据的数据结构（如B+树、哈希表），相当于书的目录，能大幅提升查询效率，但会降低插入、更新、删除的效率（需维护索引）。</p><p><strong>锁机制</strong>：用于解决并发访问时的数据竞争问题，分为表级锁（锁定整个表，开销小、并发低）和行级锁（锁定单行数据，开销大、并发高）。</p><h2 id="3-索引相关知识点"><a href="#3-索引相关知识点" class="headerlink" title="3. 索引相关知识点"></a>3. 索引相关知识点</h2><ul><li><p><strong>索引类型</strong>：<br>主键索引（PRIMARY KEY）：唯一标识一条记录，主键字段非空且唯一，一张表只能有一个主键索引。</p></li><li><p>唯一索引（UNIQUE）：索引字段的值唯一，但允许为空，一张表可以有多个唯一索引。</p></li><li><p>普通索引（INDEX）：最基础的索引，无任何约束，仅用于提升查询效率。</p></li><li><p>联合索引（复合索引）：由多个字段组合而成的索引，遵循“最左匹配原则”（查询时需从索引的第一个字段开始匹配，否则索引失效）。</p></li><li><p>全文索引（FULLTEXT）：用于全文检索，适用于CHAR、VARCHAR、TEXT类型的字段，MyISAM和InnoDB（5.6+）均支持。</p></li></ul><p><strong>索引底层数据结构</strong>：<br>        B+树：MySQL默认索引结构，非叶子节点存储索引值，叶子节点存储数据地址（InnoDB）或数据（MyISAM），叶子节点之间通过链表连接，便于范围查询。</p><p>哈希表：适用于等值查询（如memcached），但不支持范围查询和排序，MySQL中仅Memory引擎支持哈希索引。</p><p><strong>索引失效场景</strong>：<br>        使用SELECT * 查询（无法使用覆盖索引）。</p><p>索引字段使用函数（如SUBSTR(name,1,3)）、运算（如id+1&#x3D;10）。</p><p>索引字段使用模糊查询（如name LIKE ‘%张三’，%开头会导致索引失效；LIKE ‘张三%’ 则索引有效）。</p><p>联合索引未遵循最左匹配原则（如联合索引(a,b,c)，查询条件为b&#x3D;2、c&#x3D;3时索引失效）。</p><p>使用OR连接条件，其中一侧字段无索引（如id&#x3D;1 OR name&#x3D;’张三’，若name无索引则整个查询不使用索引）。</p><h2 id="4-事务隔离级别"><a href="#4-事务隔离级别" class="headerlink" title="4. 事务隔离级别"></a>4. 事务隔离级别</h2><p>MySQL默认隔离级别为RR（可重复读），不同隔离级别对应不同的并发问题，隔离级别从低到高如下：</p><ul><li><p><strong>读未提交（Read Uncommitted）</strong>：最低隔离级别，允许读取未提交的事务数据，会导致“脏读”（读取到其他事务未提交的修改）。</p></li><li><p><strong>读已提交（Read Committed，RC）</strong>：只能读取已提交的事务数据，解决脏读问题，但会导致“不可重复读”（同一事务内多次查询同一数据，结果不一致，因为其他事务修改并提交了该数据）。</p></li><li><p><strong>可重复读（Repeatable Read，RR）</strong>：同一事务内多次查询同一数据，结果一致，解决不可重复读问题，但会导致“幻读”（同一事务内多次执行同一范围查询，结果集行数不一致，因为其他事务插入了符合条件的数据）。InnoDB通过MVCC（多版本并发控制）解决了幻读问题。</p></li><li><p><strong>串行化（Serializable）</strong>：最高隔离级别，事务串行执行，完全避免脏读、不可重复读、幻读，但并发效率极低，适合数据一致性要求极高的场景（如金融交易）。</p></li></ul><p>查看隔离级别命令：<code>SELECT @@transaction_isolation;</code></p><p>设置隔离级别命令：<code>SET SESSION TRANSACTION ISOLATION LEVEL 隔离级别;</code>（如SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;）</p><h2 id="5-MVCC（多版本并发控制）"><a href="#5-MVCC（多版本并发控制）" class="headerlink" title="5. MVCC（多版本并发控制）"></a>5. MVCC（多版本并发控制）</h2><p>InnoDB实现隔离级别的核心技术，通过保存数据的多个版本，允许不同事务在并发访问时读取不同版本的数据，避免加锁（读不加锁，写加锁），提升并发效率。核心原理：</p><ul><li><p>每行数据包含隐藏列：DB_TRX_ID（事务ID，记录修改该数据的事务）、DB_ROLL_PTR（回滚指针，指向该数据的上一个版本）。</p></li><li><p>undo log（回滚日志）：保存数据的历史版本，通过回滚指针串联，事务读取数据时，根据事务ID和隔离级别选择合适的版本（快照读）。</p></li><li><p>快照读：普通SELECT查询（非锁定读），读取undo log中的历史版本，不加锁；当前读：SELECT … FOR UPDATE、SELECT … LOCK IN SHARE MODE、INSERT、UPDATE、DELETE，读取当前最新版本，加锁。</p></li></ul><h1 id="二、常用命令汇总"><a href="#二、常用命令汇总" class="headerlink" title="二、常用命令汇总"></a>二、常用命令汇总</h1><h2 id="1-数据库操作（DDL）"><a href="#1-数据库操作（DDL）" class="headerlink" title="1. 数据库操作（DDL）"></a>1. 数据库操作（DDL）</h2><ul><li><p>查看所有数据库：<code>SHOW DATABASES;</code></p></li><li><p>创建数据库：<code>CREATE DATABASE 数据库名 [CHARSET utf8mb4 COLLATE utf8mb4_unicode_ci];</code>（utf8mb4支持emoji，推荐使用）</p></li><li><p>使用数据库：<code>USE 数据库名;</code></p></li><li><p>删除数据库：<code>DROP DATABASE 数据库名;</code>（谨慎使用，数据不可恢复）</p></li><li><p>查看当前使用的数据库：<code>SELECT DATABASE();</code></p></li></ul><h2 id="2-表操作（DDL）"><a href="#2-表操作（DDL）" class="headerlink" title="2. 表操作（DDL）"></a>2. 表操作（DDL）</h2><ul><li><p>查看当前数据库所有表：<code>SHOW TABLES;</code></p></li><li><p>创建表：<br><code>CREATE TABLE 表名 ( 字段名1 数据类型 [约束条件], 字段名2 数据类型 [约束条件], ... [PRIMARY KEY (字段名)], [FOREIGN KEY (字段名) REFERENCES 关联表名(关联字段名)] ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</code><br>  示例：<br>  <code>CREATE TABLE user ( id INT PRIMARY KEY AUTO_INCREMENT COMMENT &#39;用户ID&#39;, username VARCHAR(50) NOT NULL UNIQUE COMMENT &#39;用户名&#39;, password VARCHAR(100) NOT NULL COMMENT &#39;密码&#39;, age INT DEFAULT 0 COMMENT &#39;年龄&#39;, create_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39; ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</code></p></li><li><p>查看表结构：<code>DESC 表名;</code> 或 <code>SHOW COLUMNS FROM 表名;</code></p></li><li><p>修改表名：<code>ALTER TABLE 旧表名 RENAME TO 新表名;</code></p></li><li><p>添加字段：<code>ALTER TABLE 表名 ADD 字段名 数据类型 [约束条件] [AFTER 已有字段名];</code>（AFTER指定字段位置，默认在最后）</p></li><li><p>修改字段：<code>ALTER TABLE 表名 MODIFY 字段名 新数据类型 [新约束条件];</code>（修改数据类型或约束）或 <code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 新数据类型 [新约束条件];</code>（修改字段名）</p></li><li><p>删除字段：<code>ALTER TABLE 表名 DROP 字段名;</code></p></li><li><p>删除表：<code>DROP TABLE 表名;</code>（谨慎使用）</p></li></ul><h2 id="3-数据操作（DML）"><a href="#3-数据操作（DML）" class="headerlink" title="3. 数据操作（DML）"></a>3. 数据操作（DML）</h2><ul><li><p>插入数据：<br><code>-- 插入单条数据 INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...); -- 插入多条数据 INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), ...;</code><br>示例：<code>INSERT INTO user (username, password, age) VALUES (&#39;zhangsan&#39;, &#39;123456&#39;, 20), (&#39;lisi&#39;, &#39;654321&#39;, 22);</code></p></li><li><p>更新数据：<code>UPDATE 表名 SET 字段名1=值1, 字段名2=值2, ... WHERE 条件;</code>（WHERE条件必加，否则更新全表数据）</p></li><li><p>删除数据：<br><code>-- 删除符合条件的数据（可恢复，因为会记录undo log） DELETE FROM 表名 WHERE 条件; -- 清空表数据（不可恢复，速度快，不记录日志） TRUNCATE TABLE 表名;</code></p></li></ul><h2 id="4-数据查询（DQL）"><a href="#4-数据查询（DQL）" class="headerlink" title="4. 数据查询（DQL）"></a>4. 数据查询（DQL）</h2><ul><li><p>基础查询：<br><code>-- 查询指定字段 SELECT 字段名1, 字段名2, ... FROM 表名; -- 查询所有字段（不推荐，效率低） SELECT * FROM 表名; -- 去重查询 SELECT DISTINCT 字段名 FROM 表名; -- 别名查询 SELECT 字段名 AS 别名 FROM 表名;</code></p></li><li><p>条件查询（WHERE）：<br><code>SELECT 字段名 FROM 表名 WHERE 条件; -- 常用条件运算符：=、!=、&lt;、&gt;、&lt;=、&gt;=、BETWEEN...AND...、IN、NOT IN、LIKE、IS NULL、IS NOT NULL 示例： SELECT * FROM user WHERE age BETWEEN 18 AND 30; -- 年龄在18-30之间 SELECT * FROM user WHERE username LIKE &#39;张%&#39;; -- 用户名以“张”开头 SELECT * FROM user WHERE age IS NOT NULL; -- 年龄不为空</code></p></li><li><p>排序查询（ORDER BY）：<br><code>SELECT 字段名 FROM 表名 ORDER BY 字段名1 [ASC|DESC], 字段名2 [ASC|DESC]; -- ASC：升序（默认），DESC：降序 示例：SELECT * FROM user ORDER BY age DESC, create_time ASC;</code></p></li><li><p>分页查询（LIMIT）：<br><code>-- 语法：LIMIT 偏移量, 每页条数（偏移量=（页码-1）*每页条数） SELECT 字段名 FROM 表名 LIMIT 0, 10; -- 第1页，10条数据 SELECT 字段名 FROM 表名 LIMIT 10, 10; -- 第2页，10条数据</code></p></li><li><p>聚合查询（GROUP BY + 聚合函数）：<br><code>-- 聚合函数：COUNT（统计数量）、SUM（求和）、AVG（求平均）、MAX（最大值）、MIN（最小值） SELECT 聚合函数(字段名) FROM 表名 GROUP BY 分组字段 HAVING 分组条件; -- WHERE vs HAVING：WHERE过滤行数据（分组前），HAVING过滤分组数据（分组后） 示例： SELECT age, COUNT(*) AS user_count FROM user GROUP BY age HAVING COUNT(*) &gt; 1;</code></p></li><li><p>多表连接查询：<br><code>-- 内连接（只查询匹配的数据） SELECT a.字段名, b.字段名 FROM 表a a INNER JOIN 表b b ON a.关联字段 = b.关联字段; -- 左连接（查询表a所有数据，表b匹配的数据，不匹配则为NULL） SELECT a.字段名, b.字段名 FROM 表a a LEFT JOIN 表b b ON a.关联字段 = b.关联字段; -- 右连接（查询表b所有数据，表a匹配的数据，不匹配则为NULL） SELECT a.字段名, b.字段名 FROM 表a a RIGHT JOIN 表b b ON a.关联字段 = b.关联字段;</code></p></li></ul><h2 id="5-索引操作（DDL）"><a href="#5-索引操作（DDL）" class="headerlink" title="5. 索引操作（DDL）"></a>5. 索引操作（DDL）</h2><ul><li><p>创建索引：<br><code>-- 普通索引 CREATE INDEX 索引名 ON 表名(字段名); -- 唯一索引 CREATE UNIQUE INDEX 索引名 ON 表名(字段名); -- 联合索引 CREATE INDEX 索引名 ON 表名(字段名1, 字段名2, ...); -- 全文索引 CREATE FULLTEXT INDEX 索引名 ON 表名(字段名);</code></p></li><li><p>查看索引：<code>SHOW INDEX FROM 表名;</code></p></li><li><p>删除索引：<code>DROP INDEX 索引名 ON 表名;</code></p></li></ul><h2 id="6-事务操作（DML）"><a href="#6-事务操作（DML）" class="headerlink" title="6. 事务操作（DML）"></a>6. 事务操作（DML）</h2><ul><li><p>开启事务：<code>START TRANSACTION;</code> 或 <code>BEGIN;</code></p></li><li><p>提交事务：<code>COMMIT;</code>（事务执行成功，持久化数据）</p></li><li><p>回滚事务：<code>ROLLBACK;</code>（事务执行失败，撤销所有修改）</p></li><li><p>保存点：<br><code>START TRANSACTION; UPDATE user SET age=21 WHERE id=1; SAVEPOINT sp1; -- 设置保存点 UPDATE user SET age=22 WHERE id=2; ROLLBACK TO sp1; -- 回滚到保存点（仅撤销id=2的修改，id=1的修改保留） COMMIT;</code></p></li></ul><h2 id="7-权限管理（DCL）"><a href="#7-权限管理（DCL）" class="headerlink" title="7. 权限管理（DCL）"></a>7. 权限管理（DCL）</h2><ul><li><p>创建用户：<code>CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</code>（主机名用%表示所有主机可访问）</p></li><li><p>授权用户：<code>GRANT 权限1, 权限2, ... ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;</code>（权限如SELECT、INSERT、UPDATE、DELETE、ALL PRIVILEGES（所有权限））</p></li><li><p>查看权限：<code>SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;</code></p></li><li><p>撤销权限：<code>REVOKE 权限1, 权限2, ... ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></p></li><li><p>删除用户：<code>DROP USER &#39;用户名&#39;@&#39;主机名&#39;;</code></p></li></ul><h1 id="三、高频面试题及答案"><a href="#三、高频面试题及答案" class="headerlink" title="三、高频面试题及答案"></a>三、高频面试题及答案</h1><h2 id="1-基础概念类"><a href="#1-基础概念类" class="headerlink" title="1. 基础概念类"></a>1. 基础概念类</h2><h3 id="Q1：MySQL中InnoDB和MyISAM的区别？"><a href="#Q1：MySQL中InnoDB和MyISAM的区别？" class="headerlink" title="Q1：MySQL中InnoDB和MyISAM的区别？"></a>Q1：MySQL中InnoDB和MyISAM的区别？</h3><p>A：核心区别如下：</p><ul><li><p>事务支持：InnoDB支持事务，MyISAM不支持。</p></li><li><p>锁机制：InnoDB支持行级锁和表级锁，MyISAM仅支持表级锁。</p></li><li><p>外键支持：InnoDB支持外键，MyISAM不支持。</p></li><li><p>存储结构：InnoDB将数据和索引存储在一个文件（.ibd），MyISAM分为数据文件（.MYD）和索引文件（.MYI）。</p></li><li><p>查询效率：MyISAM查询速度快（适合读多写少），InnoDB写入、更新效率高（适合高并发、写多读少）。</p></li><li><p>崩溃恢复：InnoDB支持崩溃恢复（通过redo log），MyISAM不支持，崩溃后可能丢失数据。</p></li></ul><h3 id="Q2：什么是事务？事务的ACID特性是什么？"><a href="#Q2：什么是事务？事务的ACID特性是什么？" class="headerlink" title="Q2：什么是事务？事务的ACID特性是什么？"></a>Q2：什么是事务？事务的ACID特性是什么？</h3><p>A：事务是数据库中一组不可分割的操作单元，要么全部执行，要么全部不执行。ACID特性如下：</p><ul><li><p>原子性（Atomicity）：事务是最小执行单位，不可拆分，要么全成功，要么全失败。</p></li><li><p>一致性（Consistency）：事务执行前后，数据库的完整性约束（如主键唯一、外键关联）不被破坏。</p></li><li><p>隔离性（Isolation）：多个事务并发执行时，一个事务的操作不会被其他事务干扰。</p></li><li><p>持久性（Durability）：事务提交后，对数据库的修改永久保存，即使数据库崩溃也不会丢失。</p></li></ul><h3 id="Q3：MySQL的事务隔离级别有哪些？默认是哪个？各隔离级别会出现什么并发问题？"><a href="#Q3：MySQL的事务隔离级别有哪些？默认是哪个？各隔离级别会出现什么并发问题？" class="headerlink" title="Q3：MySQL的事务隔离级别有哪些？默认是哪个？各隔离级别会出现什么并发问题？"></a>Q3：MySQL的事务隔离级别有哪些？默认是哪个？各隔离级别会出现什么并发问题？</h3><p>A：隔离级别从低到高为：读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）、串行化（Serializable）。MySQL默认隔离级别是可重复读（RR）。</p><p>各隔离级别对应的并发问题：</p><ul><li><p>读未提交：存在脏读、不可重复读、幻读。</p></li><li><p>读已提交：解决脏读，存在不可重复读、幻读。</p></li><li><p>可重复读：解决脏读、不可重复读，InnoDB通过MVCC解决了幻读，理论上存在幻读。</p></li><li><p>串行化：解决所有并发问题，事务串行执行，并发效率极低。</p></li></ul><h2 id="2-索引类"><a href="#2-索引类" class="headerlink" title="2. 索引类"></a>2. 索引类</h2><h3 id="Q1：什么是索引？索引的作用是什么？优缺点是什么？"><a href="#Q1：什么是索引？索引的作用是什么？优缺点是什么？" class="headerlink" title="Q1：什么是索引？索引的作用是什么？优缺点是什么？"></a>Q1：什么是索引？索引的作用是什么？优缺点是什么？</h3><p>A：索引是帮助MySQL高效查询数据的数据结构，相当于书的目录。</p><p>作用：提升查询效率，减少数据库扫描的数据量。</p><p>优点：1. 大幅提升查询速度；2. 减少排序和分组操作的时间（索引本身有序）。</p><p>缺点：1. 增加存储开销（索引需要占用磁盘空间）；2. 降低写入效率（插入、更新、删除时需维护索引）；3. 索引过多会增加优化器的选择成本。</p><h3 id="Q2：MySQL索引的底层数据结构是什么？为什么用B-树而不用B树或哈希表？"><a href="#Q2：MySQL索引的底层数据结构是什么？为什么用B-树而不用B树或哈希表？" class="headerlink" title="Q2：MySQL索引的底层数据结构是什么？为什么用B+树而不用B树或哈希表？"></a>Q2：MySQL索引的底层数据结构是什么？为什么用B+树而不用B树或哈希表？</h3><p>A：MySQL默认索引结构是B+树（InnoDB和MyISAM均使用）。</p><p>选择B+树的原因：</p><ul><li><p>对比B树：B+树非叶子节点仅存储索引值，不存储数据，因此非叶子节点占用空间更小，可在内存中缓存更多索引，减少磁盘I&#x2F;O（磁盘I&#x2F;O是数据库性能瓶颈）；B+树叶子节点通过链表连接，便于范围查询（B树需遍历整棵树）。</p></li><li><p>对比哈希表：哈希表仅支持等值查询（查询速度快），不支持范围查询、排序、模糊查询；哈希表存在哈希冲突问题，MySQL中仅Memory引擎支持哈希索引，适用场景有限。</p></li></ul><h3 id="Q3：什么是联合索引？联合索引的最左匹配原则是什么？"><a href="#Q3：什么是联合索引？联合索引的最左匹配原则是什么？" class="headerlink" title="Q3：什么是联合索引？联合索引的最左匹配原则是什么？"></a>Q3：什么是联合索引？联合索引的最左匹配原则是什么？</h3><p>A：联合索引是由多个字段组合而成的索引（如INDEX idx_a_b_c(a,b,c)）。</p><p>最左匹配原则：查询时需从联合索引的第一个字段开始匹配，否则索引失效。例如：</p><ul><li><p>查询条件a&#x3D;1 → 匹配索引，有效。</p></li><li><p>查询条件a&#x3D;1 AND b&#x3D;2 → 匹配索引，有效。</p></li><li><p>查询条件a&#x3D;1 AND b&#x3D;2 AND c&#x3D;3 → 匹配索引，有效。</p></li><li><p>查询条件b&#x3D;2 → 不匹配第一个字段，索引失效。</p></li><li><p>查询条件b&#x3D;2 AND c&#x3D;3 → 不匹配第一个字段，索引失效。</p></li><li><p>查询条件a&#x3D;1 AND c&#x3D;3 → 仅匹配a字段，b字段缺失，索引仅a字段生效，c字段不生效。</p></li></ul><h3 id="Q4：哪些场景下索引会失效？"><a href="#Q4：哪些场景下索引会失效？" class="headerlink" title="Q4：哪些场景下索引会失效？"></a>Q4：哪些场景下索引会失效？</h3><p>A：常见索引失效场景：</p><ul><li><p>使用SELECT * 查询（无法使用覆盖索引，可能导致全表扫描）。</p></li><li><p>索引字段使用函数（如SUBSTR(name,1,3)、DATE(create_time)）或运算（如id+1&#x3D;10、age*2&#x3D;40）。</p></li><li><p>索引字段使用模糊查询且%开头（如name LIKE ‘%张三’，%开头会导致索引失效；LIKE ‘张三%’ 则索引有效）。</p></li><li><p>联合索引未遵循最左匹配原则。</p></li><li><p>使用OR连接条件，其中一侧字段无索引（如id&#x3D;1 OR name&#x3D;’张三’，若name无索引则整个查询不使用索引）。</p></li><li><p>索引字段的值为NULL（IS NULL可能失效，取决于MySQL版本和数据分布，建议字段设置默认值）。</p></li><li><p>数据量过小（MySQL优化器认为全表扫描比走索引更快）。</p></li></ul><h2 id="3-事务与并发类"><a href="#3-事务与并发类" class="headerlink" title="3. 事务与并发类"></a>3. 事务与并发类</h2><h3 id="Q1：什么是脏读、不可重复读、幻读？如何解决？"><a href="#Q1：什么是脏读、不可重复读、幻读？如何解决？" class="headerlink" title="Q1：什么是脏读、不可重复读、幻读？如何解决？"></a>Q1：什么是脏读、不可重复读、幻读？如何解决？</h3><p>A：</p><ul><li><p>脏读：一个事务读取到另一个事务未提交的修改数据。例如：事务A更新了数据但未提交，事务B读取了该数据，随后事务A回滚，事务B读取的数据是“脏数据”。解决：提升隔离级别到读已提交（RC）及以上。</p></li><li><p>不可重复读：同一事务内多次查询同一数据，结果不一致（因为其他事务修改并提交了该数据）。例如：事务A两次查询id&#x3D;1的用户年龄，第一次查询为20，期间事务B将年龄改为22并提交，事务A第二次查询为22。解决：提升隔离级别到可重复读（RR）及以上。</p></li><li><p>幻读：同一事务内多次执行同一范围查询，结果集行数不一致（因为其他事务插入了符合条件的数据）。例如：事务A查询年龄&gt;18的用户有10条，期间事务B插入了1条年龄20的用户并提交，事务A再次查询为11条。解决：InnoDB通过MVCC解决幻读；或提升隔离级别到串行化。</p></li></ul><h3 id="Q2：InnoDB的MVCC原理是什么？"><a href="#Q2：InnoDB的MVCC原理是什么？" class="headerlink" title="Q2：InnoDB的MVCC原理是什么？"></a>Q2：InnoDB的MVCC原理是什么？</h3><p>A：MVCC（多版本并发控制）是InnoDB实现隔离级别的核心技术，通过保存数据的多个版本，允许不同事务并发访问时读取不同版本的数据，实现“读不加锁，写加锁”，提升并发效率。核心原理：</p><ul><li><p>每行数据包含隐藏列：DB_TRX_ID（事务ID，记录修改该数据的事务）、DB_ROLL_PTR（回滚指针，指向该数据的上一个版本）。</p></li><li><p>undo log（回滚日志）：保存数据的历史版本，通过回滚指针串联成版本链。当事务修改数据时，InnoDB会先将数据的旧版本写入undo log，再修改当前数据。</p></li><li><p>Read View（读视图）：事务开启时生成的一个“快照”，包含当前活跃事务的ID列表。事务读取数据时，通过Read View判断数据版本是否可见：<br>若数据的DB_TRX_ID小于Read View中的最小活跃事务ID → 数据可见（该事务已提交）。</p></li><li><p>若数据的DB_TRX_ID大于Read View中的最大活跃事务ID → 数据不可见（该事务在当前事务开启后才启动）。</p></li><li><p>若数据的DB_TRX_ID在活跃事务ID列表中 → 数据不可见（该事务未提交）；否则可见。</p></li></ul><p>快照读与当前读：普通SELECT查询是快照读（读取undo log中的历史版本，不加锁）；SELECT … FOR UPDATE、INSERT、UPDATE、DELETE是当前读（读取最新版本，加锁）。</p><h3 id="Q3：InnoDB的锁机制有哪些？行级锁的实现原理是什么？"><a href="#Q3：InnoDB的锁机制有哪些？行级锁的实现原理是什么？" class="headerlink" title="Q3：InnoDB的锁机制有哪些？行级锁的实现原理是什么？"></a>Q3：InnoDB的锁机制有哪些？行级锁的实现原理是什么？</h3><p>A：InnoDB支持表级锁和行级锁，行级锁是InnoDB的核心锁机制。</p><ul><li><p>表级锁：锁定整个表，开销小、加锁快，并发度低，适用于全表操作（如ALTER TABLE）。分为表共享锁（S锁，允许其他事务读，禁止写）和表排他锁（X锁，禁止其他事务读和写）。</p></li><li><p>行级锁：锁定单行数据，开销大、加锁慢，并发度高，适用于高并发场景。分为行共享锁（S锁，允许其他事务读该行，禁止写）和行排他锁（X锁，禁止其他事务读和写该行）。</p></li><li><p>意向锁：表级锁，用于标识表中是否有行级锁，避免表级锁和行级锁的冲突。分为意向共享锁（IS锁，事务准备给表中某些行加S锁）和意向排他锁（IX锁，事务准备给表中某些行加X锁）。</p></li></ul><p>行级锁的实现原理：InnoDB的行级锁是基于索引实现的，若查询语句未使用索引（全表扫描），则会升级为表级锁。例如：UPDATE user SET age&#x3D;21 WHERE id&#x3D;1（id是主键索引） → 加行级锁；UPDATE user SET age&#x3D;21 WHERE username&#x3D;’zhangsan’（username无索引） → 加表级锁。</p><h2 id="4-性能优化类"><a href="#4-性能优化类" class="headerlink" title="4. 性能优化类"></a>4. 性能优化类</h2><h3 id="Q1：MySQL查询优化的常用方法有哪些？"><a href="#Q1：MySQL查询优化的常用方法有哪些？" class="headerlink" title="Q1：MySQL查询优化的常用方法有哪些？"></a>Q1：MySQL查询优化的常用方法有哪些？</h3><p>A：常用查询优化方法：</p><ul><li><p>合理创建索引：针对查询频繁的字段创建索引，避免索引过多；使用联合索引时遵循最左匹配原则；避免索引失效场景。</p></li><li><p>优化SQL语句：<br>避免SELECT *，只查询需要的字段（使用覆盖索引）。</p></li><li><p>避免使用子查询，改用JOIN（子查询可能导致全表扫描，JOIN效率更高）。</p></li><li><p>避免使用OR，改用IN（OR可能导致索引失效，IN在数据量小时效率高）。</p></li><li><p>使用LIMIT分页，避免一次性查询大量数据。</p></li><li><p>避免在WHERE条件中使用函数或运算。</p></li></ul><p>优化表结构：<br>        选择合适的数据类型（如用INT代替VARCHAR存储数字，用VARCHAR代替TEXT存储短文本）。</p><p>字段设置为NOT NULL（避免NULL值导致索引失效，减少存储开销）。</p><p>使用自增主键（InnoDB主键索引是聚簇索引，自增主键可避免索引碎片）。</p><p>分库分表：当数据量过大（如千万级、亿级）时，单库单表性能瓶颈明显，可通过分库（按业务拆分数据库）、分表（水平分表：按数据范围或哈希拆分；垂直分表：按字段拆分）提升性能。</p><p>开启查询缓存（MySQL 8.0已移除）：对于查询频繁且数据不常变化的场景，开启查询缓存可提升效率。</p><p>使用慢查询日志定位问题：开启慢查询日志（long_query_time设置阈值，如2秒），记录执行时间过长的SQL，针对性优化。</p><h3 id="Q2：什么是分库分表？分库分表的方案有哪些？"><a href="#Q2：什么是分库分表？分库分表的方案有哪些？" class="headerlink" title="Q2：什么是分库分表？分库分表的方案有哪些？"></a>Q2：什么是分库分表？分库分表的方案有哪些？</h3><p>A：分库分表是解决海量数据存储和高并发访问的核心方案，当单库数据量过大（如超过1000万）或单表数据量过大（如超过500万）时，会导致查询、写入效率下降，此时需要将数据库或表拆分。</p><p>分库分表方案：</p><ul><li><p>分库：<br>垂直分库：按业务模块拆分（如电商系统拆分为用户库、订单库、商品库），降低单库压力，便于维护。</p></li><li><p>水平分库：按数据范围或哈希拆分（如按用户ID哈希拆分到多个用户库），分担单库的并发压力。</p></li></ul><p>分表：<br>        垂直分表：按字段拆分（将大字段如TEXT拆分到单独的表，主表存储常用小字段），减少主表数据量，提升查询效率。</p><p>水平分表：按数据范围（如按时间拆分订单表：order_202401、order_202402）或哈希（如按用户ID哈希拆分用户表：user_00、user_01）拆分，减少单表数据量。</p><p>分库分表工具：Sharding-JDBC、MyCat等。</p><h3 id="Q3：什么是慢查询日志？如何开启和使用？"><a href="#Q3：什么是慢查询日志？如何开启和使用？" class="headerlink" title="Q3：什么是慢查询日志？如何开启和使用？"></a>Q3：什么是慢查询日志？如何开启和使用？</h3><p>A：慢查询日志是MySQL记录执行时间超过阈值（long_query_time）的SQL语句的日志，用于定位性能低下的SQL，是查询优化的重要工具。</p><p>开启和使用步骤：</p><ul><li><p>查看慢查询日志状态：<code>SHOW VARIABLES LIKE &#39;slow_query_log&#39;;</code>（ON为开启，OFF为关闭）。</p></li><li><p>开启慢查询日志：<code>SET GLOBAL slow_query_log = ON;</code>（临时开启，重启MySQL失效）；永久开启需修改my.cnf配置文件：<br><code>[mysqld] slow_query_log = 1 slow_query_log_file = /var/lib/mysql/mysql-slow.log（日志存储路径） long_query_time = 2（阈值，单位秒，默认10秒） log_queries_not_using_indexes = 1（记录未使用索引的SQL）</code></p></li><li><p>查看慢查询日志：直接查看日志文件（如cat &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql-slow.log），或使用mysqldumpslow工具分析（如<code>mysqldumpslow -s t -t 10 /var/lib/mysql/mysql-slow.log</code>：按执行时间排序，显示前10条慢查询）。</p></li></ul><h2 id="5-其他常见问题"><a href="#5-其他常见问题" class="headerlink" title="5. 其他常见问题"></a>5. 其他常见问题</h2><h3 id="Q1：MySQL中的主键和唯一索引的区别？"><a href="#Q1：MySQL中的主键和唯一索引的区别？" class="headerlink" title="Q1：MySQL中的主键和唯一索引的区别？"></a>Q1：MySQL中的主键和唯一索引的区别？</h3><p>A：核心区别：</p><ul><li><p>非空约束：主键字段必须非空（NOT NULL），唯一索引字段可以为空（NULL）。</p></li><li><p>数量限制：一张表只能有一个主键，可多个唯一索引。</p></li><li><p>索引类型：InnoDB中主键索引是聚簇索引（数据和索引存储在一起），唯一索引是非聚簇索引（索引存储数据地址）。</p></li><li><p>用途：主键用于唯一标识一条记录，唯一索引仅用于保证字段值唯一。</p></li></ul><h3 id="Q2：什么是聚簇索引和非聚簇索引？区别是什么？"><a href="#Q2：什么是聚簇索引和非聚簇索引？区别是什么？" class="headerlink" title="Q2：什么是聚簇索引和非聚簇索引？区别是什么？"></a>Q2：什么是聚簇索引和非聚簇索引？区别是什么？</h3><p>A：聚簇索引和非聚簇索引是InnoDB中的两种索引类型：</p><ul><li><p>聚簇索引（Clustered Index）：<br>索引和数据存储在一起，索引的叶子节点直接存储数据。</p></li><li><p>InnoDB中默认主键索引是聚簇索引，若表无主键，则选择唯一索引作为聚簇索引；若也无唯一索引，则InnoDB自动生成一个隐藏的聚簇索引。</p></li><li><p>查询效率高，因为找到索引就找到了数据。</p></li></ul><p>非聚簇索引（Non-Clustered Index）：<br>        索引和数据分开存储，索引的叶子节点存储数据的地址（聚簇索引的索引值）。</p><p>普通索引、唯一索引（非主键）均为非聚簇索引。</p><p>查询时需要先通过非聚簇索引找到聚簇索引的索引值，再通过聚簇索引找到数据，称为“回表查询”，效率比聚簇索引低。</p><p>区别：聚簇索引索引和数据一体，查询效率高，一张表仅一个；非聚簇索引索引和数据分离，需回表查询，效率较低，一张表可多个。</p><h3 id="Q3：MySQL如何实现主从复制？主从复制的作用是什么？"><a href="#Q3：MySQL如何实现主从复制？主从复制的作用是什么？" class="headerlink" title="Q3：MySQL如何实现主从复制？主从复制的作用是什么？"></a>Q3：MySQL如何实现主从复制？主从复制的作用是什么？</h3><p>A：主从复制是MySQL实现高可用、读写分离的基础，通过将主库（Master）的binlog日志同步到从库（Slave），并在从库重放日志，实现主从数据一致。</p><p>主从复制原理（三步曲）：</p><ul><li><p>主库将数据修改记录写入binlog日志（二进制日志）。</p></li><li><p>从库的IO线程连接主库，读取主库的binlog日志，写入从库的relay log（中继日志）。</p></li><li><p>从库的SQL线程读取relay log，重放日志中的SQL语句，同步主库数据。</p></li></ul><p>主从复制的作用：</p><ul><li><p>读写分离：主库负责写入（INSERT、UPDATE、DELETE），从库负责读取（SELECT），提升并发访问能力。</p></li><li><p>数据备份：从库作为主库的备份，避免主库数据丢失。</p></li><li><p>高可用：主库故障时，可将从库切换为主库，保证服务连续性。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
