<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JVM学习笔记 | 活在下雨天的博客</title><meta name="author" content="Live Rainy"><meta name="copyright" content="Live Rainy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、JVM基础概念1.1 JVM定义与作用JVM（Java Virtual Machine，Java虚拟机）是运行Java字节码的虚拟计算机，它屏蔽了不同操作系统的底层差异，实现了“一次编写，到处运行”的Java核心特性。JVM的核心作用包括：加载解析字节码、管理内存、执行字节码、处理异常、垃圾回收等。 JVM与操作系统、硬件的关系：Java源码（.java）经编译器（javac）编译为字节码文件">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM学习笔记">
<meta property="og:url" content="https://www.liverainy.online/2025/12/09/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="活在下雨天的博客">
<meta property="og:description" content="一、JVM基础概念1.1 JVM定义与作用JVM（Java Virtual Machine，Java虚拟机）是运行Java字节码的虚拟计算机，它屏蔽了不同操作系统的底层差异，实现了“一次编写，到处运行”的Java核心特性。JVM的核心作用包括：加载解析字节码、管理内存、执行字节码、处理异常、垃圾回收等。 JVM与操作系统、硬件的关系：Java源码（.java）经编译器（javac）编译为字节码文件">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://liverainy-blog-images.oss-cn-chengdu.aliyuncs.com/%E6%96%87%E7%AB%A0/pixiv/117521539_p0.jpg">
<meta property="article:published_time" content="2025-12-09T07:15:37.000Z">
<meta property="article:modified_time" content="2025-12-09T10:04:26.653Z">
<meta property="article:author" content="Live Rainy">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liverainy-blog-images.oss-cn-chengdu.aliyuncs.com/%E6%96%87%E7%AB%A0/pixiv/117521539_p0.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JVM学习笔记",
  "url": "https://www.liverainy.online/2025/12/09/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
  "image": "https://liverainy-blog-images.oss-cn-chengdu.aliyuncs.com/%E6%96%87%E7%AB%A0/pixiv/117521539_p0.jpg",
  "datePublished": "2025-12-09T07:15:37.000Z",
  "dateModified": "2025-12-09T10:04:26.653Z",
  "author": [
    {
      "@type": "Person",
      "name": "Live Rainy",
      "url": "https://www.liverainy.online"
    }
  ]
}</script><link rel="shortcut icon" href="https://liverainy-blog-images.oss-cn-chengdu.aliyuncs.com/%E6%96%87%E7%AB%A0/pixiv/117521539_p3.jpg"><link rel="canonical" href="https://www.liverainy.online/2025/12/09/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM学习笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://liverainy-blog-images.oss-cn-chengdu.aliyuncs.com/%E6%96%87%E7%AB%A0/pixiv/117521539_p1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://liverainy-blog-images.oss-cn-chengdu.aliyuncs.com/%E6%96%87%E7%AB%A0/pixiv/117521539_p0.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://liverainy-blog-images.oss-cn-chengdu.aliyuncs.com/%E6%96%87%E7%AB%A0/pixiv/117521539_p2.jpg" alt="Logo"></a><a class="nav-page-title" href="/"><span class="site-name">JVM学习笔记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">JVM学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-09T07:15:37.000Z" title="发表于 2025-12-09 15:15:37">2025-12-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-09T10:04:26.653Z" title="更新于 2025-12-09 18:04:26">2025-12-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="一、JVM基础概念"><a href="#一、JVM基础概念" class="headerlink" title="一、JVM基础概念"></a>一、JVM基础概念</h1><h2 id="1-1-JVM定义与作用"><a href="#1-1-JVM定义与作用" class="headerlink" title="1.1 JVM定义与作用"></a>1.1 JVM定义与作用</h2><p>JVM（Java Virtual Machine，Java虚拟机）是运行Java字节码的虚拟计算机，它屏蔽了不同操作系统的底层差异，实现了“一次编写，到处运行”的Java核心特性。JVM的核心作用包括：加载解析字节码、管理内存、执行字节码、处理异常、垃圾回收等。</p>
<p>JVM与操作系统、硬件的关系：Java源码（.java）经编译器（javac）编译为字节码文件（.class），JVM负责将字节码翻译为本地机器指令（不同OS对应不同JVM实现，如HotSpot、J9等），最终由硬件执行。</p>
<h2 id="1-2-JVM架构核心组成"><a href="#1-2-JVM架构核心组成" class="headerlink" title="1.2 JVM架构核心组成"></a>1.2 JVM架构核心组成</h2><p>JVM架构主要分为五大核心模块，各模块协同工作完成字节码的执行与资源管理：</p>
<ol>
<li><p><strong>类加载器子系统（ClassLoader Subsystem）</strong>：负责加载.class文件到内存，完成“加载-链接-初始化”三个阶段。核心组件包括引导类加载器（Bootstrap ClassLoader，加载JDK核心类库，如rt.jar）、扩展类加载器（Extension ClassLoader，加载jre&#x2F;lib&#x2F;ext目录下的类库）、应用程序类加载器（Application ClassLoader，加载用户应用程序的类），以及自定义类加载器（继承ClassLoader实现）。</p>
</li>
<li><p><strong>运行时数据区（Runtime Data Area）</strong>：JVM在运行时分配的内存区域，也是面试核心考点，分为线程共享区和线程私有区：<br>线程共享区（所有线程共用，随JVM启动&#x2F;退出创建&#x2F;销毁）：方法区（Method Area，存储类元信息、常量、静态变量、即时编译后的代码等，JDK8后由元空间Metaspace实现，物理内存分配，无OOM上限）、堆（Heap，存储对象实例和数组，是垃圾回收的主要区域，分为年轻代[Eden区、Survivor0区、Survivor1区]和老年代）。</p>
</li>
<li><p>线程私有区（每个线程独立拥有，随线程创建&#x2F;销毁）：程序计数器（Program Counter Register，记录当前线程执行的字节码指令地址，无OOM）、虚拟机栈（VM Stack，存储方法调用的栈帧，每个栈帧包含局部变量表、操作数栈、动态链接、方法出口等，栈深度不足会抛出StackOverflowError，内存不足会抛出OutOfMemoryError）、本地方法栈（Native Method Stack，为本地方法[如Object.wait()]提供内存空间，与虚拟机栈功能类似，也可能抛出StackOverflowError和OutOfMemoryError）。</p>
</li>
<li><p><strong>执行引擎（Execution Engine）</strong>：将字节码翻译为本地机器指令并执行，核心组件包括解释器（Interpreter，逐行解释字节码，启动快但执行慢）、即时编译器（JIT Compiler，将频繁执行的热点代码编译为本地机器码，执行快但编译耗时），以及垃圾回收器（Garbage Collector，负责回收堆和方法区中无引用的对象，释放内存）。</p>
</li>
<li><p><strong>本地方法接口（Native Method Interface，JNI）</strong>：提供Java程序调用本地方法（C&#x2F;C++编写）的接口，用于与操作系统底层交互（如文件IO、网络通信等）。</p>
</li>
<li><p><strong>本地方法库（Native Method Library）</strong>：存储本地方法的实现，供JNI调用。</p>
</li>
</ol>
<h2 id="1-3-类加载机制"><a href="#1-3-类加载机制" class="headerlink" title="1.3 类加载机制"></a>1.3 类加载机制</h2><p>类加载机制是指将.class文件加载到内存，并对其进行验证、准备、解析、初始化，最终形成可使用的类对象的过程，核心遵循“双亲委派模型”：</p>
<ol>
<li><p><strong>加载（Loading）</strong>：通过类的全限定名（如java.lang.String）找到对应的.class文件，将其字节流读取到内存，生成一个代表该类的Class对象（存储在方法区）。</p>
</li>
<li><p><strong>链接（Linking）</strong>：分为三个阶段：</p>
<ul>
<li>验证（Verification）：检查.class文件的字节流是否符合JVM规范（如文件格式验证、元数据验证、字节码验证、符号引用验证），防止恶意字节码攻击</li>
<li>准备（Preparation）：为类的静态变量分配内存，并设置默认初始值（如int默认0、boolean默认false、引用类型默认null），不包含实例变量（实例变量在对象创建时分配在堆中）。</li>
<li>解析（Resolution）：将类中的符号引用（如类名、方法名、字段名）转换为直接引用（内存地址）。</li>
</ul>
</li>
<li><p><strong>初始化（Initialization）</strong>：执行类的静态代码块（static{}）和静态变量的显式赋值语句，初始化顺序遵循“父类优先于子类、静态变量按声明顺序、静态代码块按顺序执行”。</p>
</li>
</ol>
<p>双亲委派模型：当一个类加载器收到类加载请求时，首先委托给父类加载器加载，只有父类加载器无法加载（找不到对应的.class文件）时，才由当前类加载器自己加载。优势：避免类重复加载、保证核心类库的安全性（如防止用户自定义java.lang.String类覆盖核心类）。</p>
<h2 id="1-4-垃圾回收（GC）核心概念"><a href="#1-4-垃圾回收（GC）核心概念" class="headerlink" title="1.4 垃圾回收（GC）核心概念"></a>1.4 垃圾回收（GC）核心概念</h2><p>垃圾回收是指JVM自动回收堆和方法区中无引用对象的内存空间，核心解决“哪些对象需要回收”“何时回收”“如何回收”三个问题：</p>
<ol>
<li><strong>垃圾判定算法</strong>：<ul>
<li>引用计数法（Reference Counting）：为每个对象维护一个引用计数器，被引用时计数器+1，引用失效时-1，计数器为0则认为是垃圾。缺点：无法解决循环引用问题（如A引用B，B引用A，计数器均不为0，但实际无外部引用）。</li>
<li>可达性分析算法（Reachability Analysis）：JVM主流采用的算法，以“GC Roots”为起点，通过引用链遍历对象，无法到达的对象即为垃圾。GC Roots包括：虚拟机栈中局部变量表的引用对象、本地方法栈中本地方法的引用对象、方法区中静态变量和常量的引用对象、活跃线程的引用对象等。</li>
</ul>
</li>
<li><strong>引用类型（JDK1.2后）</strong>：<ul>
<li>强引用（Strong Reference）：如Object obj &#x3D; new Object()，只要强引用存在，对象不会被回收，即使OOM也不回收。</li>
<li>软引用（Soft Reference）：用于缓存场景，当内存不足时，JVM会回收软引用关联的对象。</li>
<li>弱引用（Weak Reference）：用于临时缓存，只要发生GC，无论内存是否充足，都会回收弱引用关联的对象。</li>
<li>虚引用（Phantom Reference）：无实际引用意义，仅用于监听对象被GC回收的事件，必须与ReferenceQueue配合使用。</li>
</ul>
</li>
<li><strong>GC算法</strong>：<ul>
<li>标记-清除算法（Mark-Sweep）：分为标记（标记垃圾对象）和清除（回收垃圾对象内存）两个阶段。优点：简单高效；缺点：产生内存碎片，后续大对象分配可能失败。</li>
<li>标记-复制算法（Mark-Copy）：将堆内存分为两块，只使用其中一块，GC时标记存活对象，复制到另一块未使用的内存，然后清空原使用块。优点：无内存碎片；缺点：内存利用率低（仅50%），适合年轻代（存活对象少）。</li>
<li>标记-整理算法（Mark-Compact）：标记存活对象后，将存活对象向内存一端移动，然后清空另一端的垃圾内存。优点：无内存碎片、内存利用率高；缺点：移动对象耗时，适合老年代（存活对象多）。</li>
<li>分代收集算法（Generational Collection）：结合上述算法的优势，根据对象存活周期将堆分为年轻代和老年代：年轻代采用标记-复制算法（存活对象少，复制成本低），老年代采用标记-清除或标记-整理算法（存活对象多，避免频繁复制）。</li>
</ul>
</li>
<li><strong>垃圾收集器</strong>：JVM的GC实现，不同收集器适用于不同场景，常见的有：Serial（串行收集器，单线程GC，适合单CPU环境）、ParNew（Serial的并行版本，多线程GC，年轻代专用）、Parallel Scavenge（并行收集器，注重吞吐量，年轻代专用）、Serial Old（Serial的老年代版本，串行标记-整理）、Parallel Old（Parallel Scavenge的老年代版本，并行标记-整理）、CMS（Concurrent Mark Sweep，并发标记清除，注重响应时间，老年代专用，并发GC，减少停顿）、G1（Garbage-First，区域化分代式收集器，兼顾吞吐量和响应时间，可管理整个堆）、ZGC&#x2F;Shenandoah（低延迟收集器，适合大内存、低停顿场景）。</li>
</ol>
<h1 id="二、JVM常用命令及示例"><a href="#二、JVM常用命令及示例" class="headerlink" title="二、JVM常用命令及示例"></a>二、JVM常用命令及示例</h1><p>JVM提供了一系列命令行工具（位于JDK的bin目录下），用于监控JVM运行状态、排查内存泄漏、分析GC情况等，是面试和工作中必备的工具，以下是常用命令及具体示例：</p>
<h2 id="2-1-jps：Java进程状态工具"><a href="#2-1-jps：Java进程状态工具" class="headerlink" title="2.1 jps：Java进程状态工具"></a>2.1 jps：Java进程状态工具</h2><p>作用：列出当前运行的Java进程（类似ps命令），输出进程ID（PID）和主类名。</p>
<p>语法：jps [选项]</p>
<p>常用选项：</p>
<ul>
<li><p>-l：输出主类的全限定名（若为Jar包，输出Jar包路径）。</p>
</li>
<li><p>-v：输出JVM启动参数。</p>
</li>
<li><p>-m：输出Java进程的启动参数（main方法的参数）。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有Java进程的PID和主类名</span></span><br><span class="line">jps</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">12345 HelloWorld</span><br><span class="line">67890 org.springframework.boot.loader.JarLauncher</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出PID、主类全限定名</span></span><br><span class="line">jps -l</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">12345 com.example.HelloWorld</span><br><span class="line">67890 /usr/local/app/spring-boot-app.jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出PID、主类名及JVM启动参数</span></span><br><span class="line">jps -v</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">12345 HelloWorld -Xms512m -Xmx1024m -XX:+UseG1GC</span><br><span class="line">67890 org.springframework.boot.loader.JarLauncher -Xms2g -Xmx2g -XX:MetaspaceSize=256m</span><br></pre></td></tr></table></figure>

<h2 id="2-2-jstat：JVM统计监控工具"><a href="#2-2-jstat：JVM统计监控工具" class="headerlink" title="2.2 jstat：JVM统计监控工具"></a>2.2 jstat：JVM统计监控工具</h2><p>作用：实时监控JVM的内存使用、GC情况、类加载情况等统计信息。</p>
<p>语法：jstat [选项] 进程ID [间隔时间(毫秒)] [查询次数]</p>
<p>常用选项：</p>
<ul>
<li><p>-class：监控类加载、卸载数量、总空间及类加载耗时。</p>
</li>
<li><p>-gc：监控堆内存各区域（Eden、Survivor、Old）的使用情况及GC次数、耗时。</p>
</li>
<li><p>-gcutil：监控堆内存各区域的使用率及GC统计信息（百分比形式，更直观）。</p>
</li>
<li><p>-gccapacity：监控堆内存各区域的最大容量、最小容量、当前容量。</p>
</li>
<li><p>-gcnew：监控年轻代GC情况。</p>
</li>
<li><p>-gcold：监控老年代GC情况。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监控进程12345的类加载情况，每1000毫秒查询一次，共查询5次</span></span><br><span class="line">jstat -class 12345 1000 5</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     Time   </span><br><span class="line">  1234   2345678      0        0     123.45</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控进程12345的GC情况，实时输出（无查询次数，需手动终止）</span></span><br><span class="line">jstat -gc 12345</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">10240.0 10240.0  0.0    0.0    61440.0  30720.0   122880.0    61440.0   24576.0 23040.0 3072.0 2816.0      5    0.025   1      0.050    0.075</span><br><span class="line"><span class="comment"># 说明：</span></span><br><span class="line"><span class="comment"># S0C/S1C：Survivor0/1区容量（KB）；S0U/S1U：Survivor0/1区已使用容量（KB）</span></span><br><span class="line"><span class="comment"># EC/EU：Eden区容量/已使用容量；OC/OU：老年代容量/已使用容量</span></span><br><span class="line"><span class="comment"># MC/MU：元空间容量/已使用容量；CCSC/CCSU：压缩类空间容量/已使用容量</span></span><br><span class="line"><span class="comment"># YGC/YGCT：年轻代GC次数/总耗时（秒）；FGC/FGCT：老年代GC次数/总耗时；GCT：GC总耗时</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控进程12345的堆内存使用率，每2000毫秒查询一次</span></span><br><span class="line">jstat -gcutil 12345 2000</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">  0.00   0.00  50.00  50.00  93.75  91.67      5    0.025   1      0.050    0.075</span><br><span class="line"><span class="comment"># 说明：各字段为对应区域的使用率（%）</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-jmap：JVM内存映像工具"><a href="#2-3-jmap：JVM内存映像工具" class="headerlink" title="2.3 jmap：JVM内存映像工具"></a>2.3 jmap：JVM内存映像工具</h2><p>作用：生成JVM的内存快照（heap dump），查看堆内存中对象的分布情况，排查内存泄漏。</p>
<p>语法：jmap [选项] 进程ID</p>
<p>常用选项：</p>
<ul>
<li><p>-heap：查看堆内存的详细配置（如分代大小、GC算法、收集器等）及使用情况。</p>
</li>
<li><p>-histo：查看堆内存中对象的统计信息（类名、实例数量、占用内存大小）。</p>
</li>
<li><p>-dump:format&#x3D;b,file&#x3D;文件名.hprof：生成堆内存快照（二进制格式），后续可通过jhat或VisualVM分析。</p>
</li>
<li><p>-permstat（JDK7及之前）&#x2F; -clstats（JDK8+）：查看永久代&#x2F;元空间的类加载器统计信息。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看进程12345的堆内存配置及使用情况</span></span><br><span class="line">jmap -heap 12345</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">Attaching to process ID 12345, please <span class="built_in">wait</span>...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 17.0.6+10-LTS</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Garbage-First (G1) GC with 4 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 40</span><br><span class="line">   MaxHeapFreeRatio         = 70</span><br><span class="line">   MaxHeapSize              = 1073741824 (1024.0MB)</span><br><span class="line">   NewSize                  = 357564416 (341.0MB)</span><br><span class="line">   MaxNewSize               = 644245094 (614.4MB)</span><br><span class="line">   OldSize                  = 716208128 (683.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 268435456 (256.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 1073741824 (1024.0MB)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程12345的堆内存对象统计，按内存占用降序排列</span></span><br><span class="line">jmap -histo 12345 | <span class="built_in">sort</span> -k 3 -n -r | <span class="built_in">head</span> -10</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line"> num     <span class="comment">#instances         #bytes  class name (module)</span></span><br><span class="line">-------------------------------------------------------</span><br><span class="line">   1:          1234        567890  java.lang.String (java.base)</span><br><span class="line">   2:           456        234567  java.util.HashMap<span class="variable">$Node</span> (java.base)</span><br><span class="line">   3:           789        198765  com.example.User (unnamed module @0x12345678)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成进程12345的堆内存快照，保存为heap_dump.hprof</span></span><br><span class="line">jmap -dump:format=b,file=heap_dump.hprof 12345</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">Dumping heap to /home/user/heap_dump.hprof ...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure>

<h2 id="2-4-jhat：JVM堆快照分析工具"><a href="#2-4-jhat：JVM堆快照分析工具" class="headerlink" title="2.4 jhat：JVM堆快照分析工具"></a>2.4 jhat：JVM堆快照分析工具</h2><p>作用：分析jmap生成的堆内存快照（.hprof文件），提供Web界面查看对象分布、引用关系等，排查内存泄漏。</p>
<p>语法：jhat [选项] 堆快照文件名.hprof</p>
<p>常用选项：</p>
<ul>
<li><p>-port：指定Web服务端口（默认7000）。</p>
</li>
<li><p>-exclude：排除指定包名的类，减少分析数据量。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分析heap_dump.hprof文件，启动Web服务，端口7001</span></span><br><span class="line">jhat -port 7001 heap_dump.hprof</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">Reading from heap_dump.hprof...</span><br><span class="line">Dump file created Mon Dec 09 10:00:00 CST 2025</span><br><span class="line">Snapshot <span class="built_in">read</span>, resolving...</span><br><span class="line">Resolving 123456 objects...</span><br><span class="line">Chasing references, expect 24 dots........................</span><br><span class="line">Eliminating duplicate references........................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 7001</span><br><span class="line">Server is ready.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问Web界面：http://localhost:7001，可查看：</span></span><br><span class="line"><span class="comment"># 1. 所有类的统计信息（实例数、内存占用）</span></span><br><span class="line"><span class="comment"># 2. 对象的引用关系（反向引用，找到内存泄漏的根源）</span></span><br><span class="line"><span class="comment"># 3. 堆内存的整体使用情况</span></span><br></pre></td></tr></table></figure>

<h2 id="2-5-jstack：JVM线程快照工具"><a href="#2-5-jstack：JVM线程快照工具" class="headerlink" title="2.5 jstack：JVM线程快照工具"></a>2.5 jstack：JVM线程快照工具</h2><p>作用：生成JVM的线程快照（线程堆栈），查看线程的运行状态（如RUNNABLE、BLOCKED、WAITING）、调用栈信息，排查线程死锁、线程阻塞、CPU占用过高等问题。</p>
<p>语法：jstack [选项] 进程ID</p>
<p>常用选项：</p>
<ul>
<li><p>-F：强制生成线程快照（当进程无响应时使用）。</p>
</li>
<li><p>-l：显示线程的锁信息（如持有锁、等待锁的情况）。</p>
</li>
<li><p>-m：显示线程的本地方法调用栈（结合本地方法库分析）。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成进程12345的线程快照，包含锁信息，保存到thread_dump.txt</span></span><br><span class="line">jstack -l 12345 &gt; thread_dump.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看线程快照中的死锁信息（jstack会自动检测死锁并标注）</span></span><br><span class="line">grep -A 20 <span class="string">&quot;Deadlock detected&quot;</span> thread_dump.txt</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span>:</span><br><span class="line">  waiting <span class="keyword">for</span> ownable synchronizer 0x000000076ab04000, (a java.util.concurrent.locks.ReentrantLock<span class="variable">$NonfairSync</span>)</span><br><span class="line">  <span class="built_in">which</span> is held by <span class="string">&quot;Thread-0&quot;</span></span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span>:</span><br><span class="line">  waiting <span class="keyword">for</span> ownable synchronizer 0x000000076ab04020, (a java.util.concurrent.locks.ReentrantLock<span class="variable">$NonfairSync</span>)</span><br><span class="line">  <span class="built_in">which</span> is held by <span class="string">&quot;Thread-1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定线程的运行状态（如查找BLOCKED状态的线程）</span></span><br><span class="line">grep <span class="string">&quot;java.lang.Thread.State: BLOCKED&quot;</span> thread_dump.txt -B 5 -A 5</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line"><span class="string">&quot;Thread-2&quot;</span> <span class="comment">#10 prio=5 os_prio=0 cpu=0.00ms elapsed=123.45s tid=0x00007f89a0002000 nid=0x2468 waiting for monitor entry [0x00007f8998f7e000]</span></span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at com.example.Service.doSomething(Service.java:45)</span><br><span class="line">        - waiting to lock &lt;0x000000076ab06000&gt; (a com.example.Service)</span><br><span class="line">        at com.example.Thread2.run(Thread2.java:20)</span><br></pre></td></tr></table></figure>

<h2 id="2-6-jinfo：JVM配置信息工具"><a href="#2-6-jinfo：JVM配置信息工具" class="headerlink" title="2.6 jinfo：JVM配置信息工具"></a>2.6 jinfo：JVM配置信息工具</h2><p>作用：查看或修改JVM的运行时配置参数（如-Xms、-Xmx、-XX:XXX等）。</p>
<p>语法：jinfo [选项] 进程ID</p>
<p>常用选项：</p>
<ul>
<li><p>-flags：查看JVM的所有启动参数（包括默认参数和用户指定参数）。</p>
</li>
<li><p>-sysprops：查看Java系统属性（System.getProperties()的内容）。</p>
</li>
<li><p>-flag 参数名：查看指定参数的值（如-flag MaxHeapSize）。</p>
</li>
<li><p>-flag [+&#x2F;-]参数名：动态开启&#x2F;关闭指定的布尔型参数（如-flag +UseG1GC）。</p>
</li>
<li><p>-flag 参数名&#x3D;值：动态修改指定参数的值（仅部分参数支持，如-flag HeapDumpPath&#x3D;&#x2F;tmp&#x2F;）。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看进程12345的所有JVM启动参数</span></span><br><span class="line">jinfo -flags 12345</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">Attaching to process ID 12345, please <span class="built_in">wait</span>...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 17.0.6+10-LTS</span><br><span class="line">Non-default VM flags: -XX:CICompilerCount=4 -XX:InitialHeapSize=536870912 -XX:MaxHeapSize=1073741824 -XX:MetaspaceSize=268435456 -XX:MaxMetaspaceSize=1073741824 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC</span><br><span class="line">Command line:  -Xms512m -Xmx1024m -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=1024m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程12345的Java系统属性</span></span><br><span class="line">jinfo -sysprops 12345</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">java.runtime.name=OpenJDK Runtime Environment</span><br><span class="line">java.vm.version=17.0.6+10-LTS</span><br><span class="line">java.home=/usr/local/jdk17</span><br><span class="line">java.class.path=./target/classes:./lib/spring-boot-starter.jar</span><br><span class="line">user.dir=/home/user/project</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程12345的MaxHeapSize参数值</span></span><br><span class="line">jinfo -flag MaxHeapSize 12345</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">-XX:MaxHeapSize=1073741824</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态开启进程12345的HeapDumpOnOutOfMemoryError参数（OOM时自动生成堆快照）</span></span><br><span class="line">jinfo -flag +HeapDumpOnOutOfMemoryError 12345</span><br></pre></td></tr></table></figure>

<h1 id="三、JVM相关面试题"><a href="#三、JVM相关面试题" class="headerlink" title="三、JVM相关面试题"></a>三、JVM相关面试题</h1><h2 id="3-1-基础概念类"><a href="#3-1-基础概念类" class="headerlink" title="3.1 基础概念类"></a>3.1 基础概念类</h2><ol>
<li><p>**问题1：什么是JVM？JVM的核心作用是什么？**答：JVM（Java Virtual Machine）是运行Java字节码的虚拟计算机，它屏蔽了不同操作系统的底层差异，实现“一次编写，到处运行”。核心作用包括：加载解析.class文件、管理运行时内存（堆、栈、方法区等）、执行字节码（通过解释器或JIT编译器）、垃圾回收（自动回收无引用对象内存）、处理异常、提供本地方法调用接口（JNI）等。</p>
</li>
<li><p>**问题2：JVM的核心架构由哪些部分组成？各部分的作用是什么？**答：JVM核心架构包括五大模块：类加载器子系统：负责将.class文件加载到内存，完成加载、链接、初始化过程，遵循双亲委派模型。</p>
<ol>
<li><p>运行时数据区：存储JVM运行时的各种数据，分为线程共享区（方法区、堆）和线程私有区（程序计数器、虚拟机栈、本地方法栈）。</p>
</li>
<li><p>执行引擎：将字节码翻译为本地机器指令并执行，包含解释器、JIT编译器和垃圾回收器。</p>
</li>
<li><p>本地方法接口（JNI）：提供Java程序调用本地方法（C&#x2F;C++编写）的接口，用于与操作系统交互。</p>
</li>
<li><p>本地方法库：存储本地方法的实现，供JNI调用。</p>
</li>
</ol>
</li>
<li><p>**问题3：什么是双亲委派模型？它的优势是什么？如何打破双亲委派模型？**答：双亲委派模型是类加载器的加载规则：当一个类加载器收到加载请求时，首先委托给父类加载器加载，只有父类加载器无法加载（找不到.class文件）时，才由当前类加载器自己加载。<br>优势：① 避免类重复加载（同一类被不同类加载器加载会视为不同类）；② 保证核心类库的安全性（防止用户自定义核心类，如java.lang.String，覆盖JDK原生类）。<br>打破双亲委派模型的方式：① 重写ClassLoader的loadClass()方法（不遵循委托逻辑）；② 使用线程上下文类加载器（Thread.getContextClassLoader()），如JDBC加载驱动时，打破了核心类加载器无法加载用户应用类的限制。</p>
</li>
<li><p>**问题4：JVM运行时数据区分为哪些部分？各部分的作用是什么？可能发生哪些OOM？**答：运行时数据区分为线程共享区和线程私有区：</p>
<ol>
<li>线程共享区（所有线程共用）：<br>① 方法区（元空间，JDK8+）：存储类元信息、常量、静态变量、JIT编译后的代码等。可能发生OOM：元空间内存不足（如大量动态生成类，未及时卸载）。<br>② 堆：存储对象实例和数组，是GC主要区域。可能发生OOM：堆内存不足（如创建大量对象，GC无法回收，如内存泄漏）。</li>
<li>线程私有区（每个线程独立拥有）：<br>① 程序计数器：记录当前线程执行的字节码指令地址，无OOM（内存占用极小，JVM直接管理）。<br>② 虚拟机栈：存储方法调用的栈帧（局部变量表、操作数栈等）。可能发生：StackOverflowError（栈深度不足，如递归调用过深）、OutOfMemoryError（栈内存不足，如创建大量线程，每个线程栈占用过多内存）。<br>③ 本地方法栈：为本地方法提供内存空间，与虚拟机栈类似，可能发生StackOverflowError和OutOfMemoryError。</li>
</ol>
</li>
</ol>
<h2 id="3-2-垃圾回收类"><a href="#3-2-垃圾回收类" class="headerlink" title="3.2 垃圾回收类"></a>3.2 垃圾回收类</h2><ol>
<li><p>**问题1：JVM如何判断一个对象是垃圾？有哪些垃圾判定算法？**答：JVM判断对象为垃圾的核心标准是“对象无引用可达”。常用垃圾判定算法有两种：<br>① 引用计数法：为每个对象维护引用计数器，被引用时+1，引用失效时-1，计数器为0则为垃圾。缺点：无法解决循环引用问题（如A引用B，B引用A，计数器均不为0，但无外部引用）。<br>② 可达性分析算法：JVM主流采用，以GC Roots为起点，通过引用链遍历对象，无法到达的对象即为垃圾。GC Roots包括：虚拟机栈局部变量表的引用对象、本地方法栈本地方法的引用对象、方法区静态变量和常量的引用对象、活跃线程的引用对象等。</p>
</li>
<li><p>**问题2：Java中的引用类型有哪些？各有什么特点？**答：JDK1.2后将引用分为四类，优先级从高到低：<br>① 强引用：如Object obj &#x3D; new Object()，只要强引用存在，对象不会被GC回收，即使OOM也不回收。<br>② 软引用：用于缓存场景（如图片缓存），当内存不足时，JVM会回收软引用关联的对象。通过SoftReference类实现。<br>③ 弱引用：用于临时缓存，只要发生GC，无论内存是否充足，都会回收弱引用关联的对象。通过WeakReference类实现。<br>④ 虚引用：无实际引用意义，仅用于监听对象被GC回收的事件，必须与ReferenceQueue配合使用。通过PhantomReference类实现。</p>
</li>
<li><p>**问题3：常见的GC算法有哪些？各有什么优缺点？适用场景是什么？**答：常见GC算法包括：<br>① 标记-清除算法（Mark-Sweep）：<br>优点：简单高效，无需移动对象；<br>缺点：产生内存碎片，后续大对象分配可能失败；<br>适用场景：无（仅作为基础算法，后续算法基于其优化）。<br>② 标记-复制算法（Mark-Copy）：<br>优点：无内存碎片，实现简单；<br>缺点：内存利用率低（仅50%），复制对象耗时；<br>适用场景：年轻代（存活对象少，复制成本低）。<br>③ 标记-整理算法（Mark-Compact）：<br>优点：无内存碎片，内存利用率高；<br>缺点：移动对象耗时，需要暂停线程（STW）；<br>适用场景：老年代（存活对象多，避免频繁复制）。<br>④ 分代收集算法（Generational Collection）：<br>优点：结合上述算法优势，根据对象存活周期分代处理，兼顾效率和内存利用率；<br>缺点：实现复杂；<br>适用场景：所有主流JVM（如HotSpot），是目前最常用的GC算法。</p>
</li>
<li><p>**问题4：常见的垃圾收集器有哪些？各有什么特点？适用场景是什么？**答：常见垃圾收集器及特点、适用场景：<br>① Serial（串行收集器）：<br>特点：单线程GC，STW时间长，实现简单，内存占用少；<br>适用场景：单CPU环境、小型应用（如桌面应用）。<br>② ParNew（并行收集器）：<br>特点：Serial的并行版本，多线程GC，年轻代专用，可与CMS配合使用；<br>适用场景：多CPU环境，需要减少年轻代GC停顿时间的应用。<br>③ Parallel Scavenge（并行收集器）：<br>特点：多线程GC，年轻代专用，注重吞吐量（吞吐量&#x3D;运行用户代码时间&#x2F;(运行用户代码时间+GC时间)），可自动调节堆大小和GC频率；<br>适用场景：后台计算类应用（如大数据处理），对吞吐量要求高，对响应时间要求低。<br>④ CMS（Concurrent Mark Sweep）：<br>特点：并发GC，老年代专用，注重响应时间（STW时间短），采用标记-清除算法；<br>缺点：CPU占用高，产生内存碎片，无法处理浮动垃圾（GC过程中产生的新垃圾）；<br>适用场景：Web应用、分布式服务等对响应时间要求高的应用。<br>⑤ G1（Garbage-First）：<br>特点：区域化分代式收集器，可管理整个堆，兼顾吞吐量和响应时间，采用标记-整理算法（无内存碎片），可预测GC停顿时间；<br>适用场景：大内存应用（如堆内存10GB+），对响应时间和吞吐量均有要求的应用（如电商系统）。<br>⑥ ZGC&#x2F;Shenandoah：<br>特点：低延迟收集器，STW时间极短（毫秒级以下），支持大内存（如百GB级堆内存）；<br>适用场景：金融、电信等对延迟要求极高的核心业务系统。</p>
</li>
<li><p>**问题5：什么是STW（Stop The World）？如何减少STW对应用的影响？**答：STW是指GC过程中，JVM暂停所有用户线程的执行，只执行GC线程，目的是避免GC过程中对象引用关系发生变化，保证GC的正确性。STW会导致应用响应延迟，影响用户体验。<br>减少STW影响的方式：<br>① 选择合适的垃圾收集器（如CMS、G1、ZGC等低延迟收集器）；<br>② 优化JVM参数（如调整堆大小、分代比例、GC触发阈值等，减少GC频率和每次GC的停顿时间）；<br>③ 减少大对象的创建（大对象直接进入老年代，容易触发老年代GC，STW时间长）；<br>④ 避免内存泄漏（内存泄漏会导致堆内存不足，频繁触发GC，增加STW次数）；<br>⑤ 使用并发GC（如CMS、G1的并发标记阶段，不暂停用户线程）。</p>
</li>
</ol>
<h2 id="3-3-性能调优与问题排查类"><a href="#3-3-性能调优与问题排查类" class="headerlink" title="3.3 性能调优与问题排查类"></a>3.3 性能调优与问题排查类</h2><ol>
<li>**问题1：什么是内存泄漏？如何排查JVM内存泄漏？**答：内存泄漏是指对象不再被应用程序使用，但由于存在无效引用，导致GC无法回收该对象，长期积累会导致堆内存不足，最终触发OOM。<br>排查内存泄漏的步骤：<br>① 监控JVM内存使用：通过jstat -gcutil命令实时监控堆内存使用率，若老年代使用率持续上升，可能存在内存泄漏。<br>② 生成堆内存快照：通过jmap -dump:format&#x3D;b,file&#x3D;xxx.hprof命令生成堆快照。<br>③ 分析堆快照：使用jhat或VisualVM工具分析堆快照，查看：</li>
</ol>
<ul>
<li>哪些对象占用内存过多（实例数多、内存占比高）；</li>
<li>这些对象的引用链（找到持有这些对象的无效引用，即内存泄漏的根源，如未关闭的连接、静态集合存储大量对象未清理等）。<br>④ 验证问题：根据分析结果，检查代码中对应的引用逻辑，修复无效引用（如关闭连接、清理静态集合），重新部署后监控内存使用，确认泄漏问题解决。</li>
</ul>
<ol start="2">
<li><p>**问题2：如何排查JVM线程死锁问题？**答：排查线程死锁的步骤：<br>① 识别死锁现象：应用响应缓慢、CPU利用率低、线程无法正常执行任务。<br>② 生成线程快照：通过jstack -l 进程ID命令生成线程快照（-l选项显示锁信息）。<br>③ 分析线程快照：jstack会自动检测死锁并标注“Deadlock detected”，查看死锁线程的信息：</p>
<ul>
<li><p>每个死锁线程等待的锁（ownable synchronizer）；</p>
</li>
<li><p>每个死锁线程持有的锁（被其他线程等待的锁）；</p>
</li>
<li><p>线程的调用栈（找到死锁发生的代码位置）。</p>
</li>
</ul>
<p>④ 修复死锁：根据分析结果，调整代码中的锁获取顺序（如所有线程按相同顺序获取多个锁）、减少锁的持有时间、避免嵌套锁等，重新部署后验证问题解决。</p>
</li>
<li><p>**问题3：JVM常用的调优参数有哪些？请举例说明。**答：JVM调优参数主要分为三类：堆内存参数、GC参数、其他参数，常用示例：<br>① 堆内存参数：<br>-Xms：初始堆内存大小（如-Xms512m，JDK1.8后默认初始堆为物理内存的1&#x2F;64）；<br>-Xmx：最大堆内存大小（如-Xmx1024m，建议与-Xms设置为相同值，避免频繁调整堆大小）；<br>-Xmn：年轻代内存大小（如-Xmn384m，年轻代&#x3D;Eden+Survivor，默认年轻代占堆的1&#x2F;3）；<br>-XX:SurvivorRatio：Eden区与Survivor区的比例（如-XX:SurvivorRatio&#x3D;8，Eden:S0:S1&#x3D;8:1:1，默认8）；<br>-XX:MetaspaceSize：元空间初始大小（如-XX:MetaspaceSize&#x3D;256m，JDK8+，替代永久代）；<br>-XX:MaxMetaspaceSize：元空间最大大小（如-XX:MaxMetaspaceSize&#x3D;1024m，默认无上限，物理内存限制）。<br>② GC参数：<br>-XX:+UseG1GC：使用G1收集器（JDK9后默认）；<br>-XX:+UseConcMarkSweepGC：使用CMS收集器；<br>-XX:+UseParallelGC：使用Parallel Scavenge收集器（JDK8默认）；<br>-XX:MaxGCPauseMillis：G1收集器的最大GC停顿时间（如-XX:MaxGCPauseMillis&#x3D;200，单位毫秒）；<br>-XX:+HeapDumpOnOutOfMemoryError：OOM时自动生成堆快照（如-XX:HeapDumpPath&#x3D;&#x2F;tmp&#x2F;heap_dump.hprof指定保存路径）；<br>-XX:ParallelGCThreads：并行GC的线程数（如-XX:ParallelGCThreads&#x3D;4，默认与CPU核心数相同）。<br>③ 其他参数：<br>-XX:+PrintGCDetails：打印GC详细日志；<br>-XX:+PrintGCTimeStamps：打印GC发生的时间戳；<br>-Xss：每个线程的栈大小（如-Xss1m，默认1m，影响线程数量，栈越大可创建的线程越少）。</p>
</li>
<li><p>**问题4：如何分析JVM GC日志？*<em>答：分析GC日志的步骤：<br>① 开启GC日志：通过JVM参数开启，如-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xlog:gc</em>:file&#x3D;gc.log:time,level,tags:filecount&#x3D;5,filesize&#x3D;100m（JDK9+），将GC日志输出到文件。<br>② 关键日志字段解读：</p>
<ul>
<li><p>日志时间戳：如“2.345”表示JVM启动后2.345秒发生GC；</p>
</li>
<li><p>GC类型：Young GC（年轻代GC，如YGC、ParNew）、Full GC（老年代GC，如FGC、CMS）；</p>
</li>
<li><p>内存变化：如“Eden Space: 51200K-&gt;0K(61440K)”表示Eden区从51200K使用量变为0K（GC回收），总容量61440K；</p>
</li>
<li><p>GC耗时：如“0.0250000 secs”表示GC耗时25毫秒；</p>
</li>
<li><p>堆内存整体使用：如“Heap after GC: 61440K-&gt;30720K(102400K)”表示GC后堆内存使用量从61440K变为30720K，总容量102400K。</p>
</li>
</ul>
<p>③ 分析重点：</p>
<ul>
<li><p>GC频率：年轻代GC是否过于频繁（如每秒多次，可能是年轻代过小或创建对象过快）；</p>
</li>
<li><p>GC耗时：单次GC停顿时间是否过长（如Full GC耗时超过1秒，影响响应时间）；</p>
</li>
<li><p>内存变化：老年代使用量是否持续上升（可能存在内存泄漏）；</p>
</li>
<li><p>Full GC次数：Full GC耗时远大于Young GC，应尽量减少Full GC次数（如通过调整老年代大小、优化对象生命周期）。<br>④ 工具辅助：使用GC Easy、GCEasy、VisualVM等工具导入GC日志，自动生成分析报告（如GC频率、耗时统计、内存泄漏预警等），提升分析效率。</p>
</li>
</ul>
</li>
</ol>
<h2 id="3-4-进阶类"><a href="#3-4-进阶类" class="headerlink" title="3.4 进阶类"></a>3.4 进阶类</h2><ol>
<li><p>**问题1：什么是JIT编译器？它的作用是什么？**答：JIT（Just-In-Time）编译器是JVM执行引擎的组成部分，作用是将频繁执行的“热点代码”（如循环、频繁调用的方法）从字节码编译为本地机器码，从而提升代码执行效率。<br>JVM的执行方式：初始时通过解释器逐行解释字节码（启动快，执行慢），当JVM检测到某段代码被频繁执行（达到热点阈值），则触发JIT编译，将其编译为本地机器码，后续执行该代码时直接运行机器码（执行快，编译耗时）。<br>热点代码的判定：通过“采样计数器”（统计代码被调用的次数）和“循环计数器”（统计循环执行的次数）判定，当达到预设阈值（如方法被调用10000次，循环执行1000次），则标记为热点代码。</p>
</li>
<li><p>**问题2：JDK8中JVM的内存模型有哪些变化？为什么要做这些变化？**答：JDK8中JVM内存模型的核心变化是：将永久代（PermGen）替换为元空间（Metaspace）。<br>变化细节：</p>
</li>
</ol>
<ul>
<li>永久代（JDK7及之前）：存储类元信息、常量、静态变量等，内存分配在JVM堆中，有固定大小限制（通过-XX:PermSize和-XX:MaxPermSize指定），容易发生PermGen OOM（如动态生成大量类时）。</li>
<li>元空间（JDK8+）：存储类元信息等，内存分配在本地物理内存（而非JVM堆），默认无上限（受物理内存限制），可通过-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定初始和最大大小。<br>变化原因：<br>① 永久代大小难以确定（不同应用的类数量差异大，容易设置过小导致OOM，设置过大浪费内存）；<br>② 永久代的垃圾回收效率低（类元信息的回收条件苛刻，容易积累导致内存泄漏）；<br>③ 元空间使用本地内存，避免了永久代的内存限制，提升了JVM的稳定性和可扩展性；<br>④ 契合JDK的模块化发展（如Jigsaw项目），更好地支持类的动态加载和卸载。</li>
</ul>
<ol start="3">
<li>**问题3：什么是逃逸分析？JVM如何利用逃逸分析优化性能？**答：逃逸分析是JVM的一种静态分析技术，用于分析对象的引用范围（即对象是否会“逃逸”出当前方法或线程）。<br>对象逃逸的情况：</li>
</ol>
<ul>
<li>方法逃逸：对象被返回给方法的调用者（如return obj）；</li>
<li>线程逃逸：对象被存储到线程共享的变量中（如静态变量、堆中的对象字段）。<br>JVM利用逃逸分析的优化手段：<br>① 栈上分配（Stack Allocation）：若对象未逃逸（仅在当前方法内使用），则将对象分配在虚拟机栈的局部变量表中，而非堆中。栈上分配的</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.liverainy.online">Live Rainy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.liverainy.online/2025/12/09/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://www.liverainy.online/2025/12/09/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.liverainy.online" target="_blank">活在下雨天的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post-share"><div class="social-share" data-image="https://liverainy-blog-images.oss-cn-chengdu.aliyuncs.com/%E6%96%87%E7%AB%A0/pixiv/117521539_p0.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/12/11/HTTP%E3%80%81HTTPS%E5%92%8CTCP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="HTTP、HTTPS和TCP学习笔记"><img class="cover" src="https://liverainy-blog-images.oss-cn-chengdu.aliyuncs.com/%E6%96%87%E7%AB%A0/pixiv/118131919_p0.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">HTTP、HTTPS和TCP学习笔记</div></div><div class="info-2"><div class="info-item-1">一、核心协议知识点梳理1. TCP协议（传输控制协议）1.1 核心定位TCP是面向连接的、可靠的、基于字节流的传输层协议，位于IP协议之上，应用层协议（如HTTP）之下，负责在两个通信端点之间建立可靠的字节流传输通道。 1.2 核心特点 面向连接：通信前必须通过“三次握手”建立连接，通信结束后通过“四次挥手”释放连接。  可靠传输：通过序列号、确认应答、重传机制、流量控制、拥塞控制等保证数据不丢失、不重复、按序到达。  面向字节流：不关心应用层数据的具体含义，将应用层数据视为连续的字节流，拆分为TCP报文段传输。  双工通信：通信双方可同时发送和接收数据。  点到点通信：仅支持两个端点之间的通信，不支持多播或广播。   1.3 关键机制 **三次握手（建立连接）**目的：确保双方收发能力正常，协商初始序列号（ISN）。过程：  客户端 → 服务器：SYN&#x3D;1，Seq&#x3D;x（客户端初始序列号）  服务器 → 客户端：SYN&#x3D;1，ACK&#x3D;1，Seq&#x3D;y，Ack&#x3D;x+1（确认客户端，发送服务器初始序列号）  客户端 → 服务器：...</div></div></div></a><a class="pagination-related" href="/2025/12/09/MySql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="MySql学习笔记"><img class="cover" src="https://liverainy-blog-images.oss-cn-chengdu.aliyuncs.com/%E6%96%87%E7%AB%A0/pixiv/117516968_p0.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">MySql学习笔记</div></div><div class="info-2"><div class="info-item-1">一、MySql学习笔记1. 数据库基础概念 数据库（DB）：存储数据的仓库，按一定格式组织和存储数据，便于管理和访问。  数据库管理系统（DBMS）：管理数据库的软件，如MySQL、Oracle、SQL Server等，提供数据定义、查询、更新、控制等功能。  SQL（结构化查询语言）：用于与DBMS交互的标准语言，分为DQL（数据查询）、DML（数据操作）、DDL（数据定义）、DCL（数据控制）。  关系型数据库（RDBMS）：基于关系模型（二维表结构）的数据库，数据之间存在关联关系，支持ACID特性，MySQL是典型的RDBMS。   2. MySQL核心特性 ACID特性：事务的四大特性，保证数据的安全性和一致性。原子性（Atomicity）：事务是不可分割的最小单位，要么全部执行，要么全部不执行。  一致性（Consistency）：事务执行前后，数据库的完整性约束不被破坏（如主键唯一、外键关联正常）。  隔离性（Isolation）：多个事务并发执行时，一个事务的执行不会被其他事务干扰。  持久性（Durability）：事务一旦提交，其对数据库的修改会永久保存，即使数...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/12/11/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="MyBatis学习笔记"><img class="cover" src="https://liverainy-blog-images.oss-cn-chengdu.aliyuncs.com/nature-1563109-wallhere.com.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-11</div><div class="info-item-2">MyBatis学习笔记</div></div><div class="info-2"><div class="info-item-1">MyBatis学习笔记（含面试题）一、核心知识点梳理1. MyBatis简介1.1 核心定位MyBatis是一款优秀的持久层框架，它支持定制化SQL、存储过程以及高级映射。MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集的过程，通过XML或注解的方式将Java对象与SQL语句动态映射，简化数据持久化操作。 核心思想：将SQL与Java代码分离，通过配置文件管理SQL，降低耦合度，提高代码可维护性。 1.2 与JDBC的对比优势 JDBC需要手动加载驱动、创建连接、编写SQL、设置参数、处理结果集、关闭资源，代码冗余且繁琐；MyBatis通过配置和映射自动完成这些操作，简化开发。  JDBC的SQL语句硬编码在Java代码中，修改SQL需重新编译代码；MyBatis的SQL写在XML或注解中，修改无需编译，灵活度高。  JDBC需要手动处理参数类型匹配和结果集与Java对象的映射；MyBatis支持自动参数映射和结果集映射，支持复杂对象（一对一、一对多）映射。  MyBatis提供缓存机制（一级缓存、二级缓存），提升查询效率；JDBC需手动实现缓存。   1....</div></div></div></a><a class="pagination-related" href="/2025/12/09/MySql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="MySql学习笔记"><img class="cover" src="https://liverainy-blog-images.oss-cn-chengdu.aliyuncs.com/%E6%96%87%E7%AB%A0/pixiv/117516968_p0.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-09</div><div class="info-item-2">MySql学习笔记</div></div><div class="info-2"><div class="info-item-1">一、MySql学习笔记1. 数据库基础概念 数据库（DB）：存储数据的仓库，按一定格式组织和存储数据，便于管理和访问。  数据库管理系统（DBMS）：管理数据库的软件，如MySQL、Oracle、SQL Server等，提供数据定义、查询、更新、控制等功能。  SQL（结构化查询语言）：用于与DBMS交互的标准语言，分为DQL（数据查询）、DML（数据操作）、DDL（数据定义）、DCL（数据控制）。  关系型数据库（RDBMS）：基于关系模型（二维表结构）的数据库，数据之间存在关联关系，支持ACID特性，MySQL是典型的RDBMS。   2. MySQL核心特性 ACID特性：事务的四大特性，保证数据的安全性和一致性。原子性（Atomicity）：事务是不可分割的最小单位，要么全部执行，要么全部不执行。  一致性（Consistency）：事务执行前后，数据库的完整性约束不被破坏（如主键唯一、外键关联正常）。  隔离性（Isolation）：多个事务并发执行时，一个事务的执行不会被其他事务干扰。  持久性（Durability）：事务一旦提交，其对数据库的修改会永久保存，即使数...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://liverainy-blog-images.oss-cn-chengdu.aliyuncs.com/%E6%96%87%E7%AB%A0/pixiv/117521539_p1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Live Rainy</div><div class="author-info-description">个人技术博客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/foreverhu1998"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">LiveRainy's Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81JVM%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">一、JVM基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-JVM%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 JVM定义与作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-JVM%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 JVM架构核心组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 类加载机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88GC%EF%BC%89%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 垃圾回收（GC）核心概念</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81JVM%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.</span> <span class="toc-text">二、JVM常用命令及示例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-jps%EF%BC%9AJava%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%B7%A5%E5%85%B7"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 jps：Java进程状态工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-jstat%EF%BC%9AJVM%E7%BB%9F%E8%AE%A1%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 jstat：JVM统计监控工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-jmap%EF%BC%9AJVM%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F%E5%B7%A5%E5%85%B7"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 jmap：JVM内存映像工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-jhat%EF%BC%9AJVM%E5%A0%86%E5%BF%AB%E7%85%A7%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 jhat：JVM堆快照分析工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-jstack%EF%BC%9AJVM%E7%BA%BF%E7%A8%8B%E5%BF%AB%E7%85%A7%E5%B7%A5%E5%85%B7"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 jstack：JVM线程快照工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-jinfo%EF%BC%9AJVM%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E5%B7%A5%E5%85%B7"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 jinfo：JVM配置信息工具</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">三、JVM相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E7%B1%BB"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 基础概念类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%B1%BB"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 垃圾回收类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%8E%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E7%B1%BB"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 性能调优与问题排查类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E8%BF%9B%E9%98%B6%E7%B1%BB"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 进阶类</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/23/google62332c28725eeb00/" title="无标题"><img src="https://liverainy-blog-images.oss-cn-chengdu.aliyuncs.com/5120x2880-px-artwork-fiction-nebula-science-space-1819213-wallhere.com.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/2025/12/23/google62332c28725eeb00/" title="无标题">无标题</a><time datetime="2025-12-23T03:44:03.208Z" title="发表于 2025-12-23 11:44:03">2025-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/23/google62332c28725eeb00/" title="无标题"><img src="https://liverainy-blog-images.oss-cn-chengdu.aliyuncs.com/5120x2880-px-artwork-fiction-nebula-science-space-1819213-wallhere.com.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/2025/12/23/google62332c28725eeb00/" title="无标题">无标题</a><time datetime="2025-12-23T03:38:58.140Z" title="发表于 2025-12-23 11:38:58">2025-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/11/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="MyBatis学习笔记"><img src="https://liverainy-blog-images.oss-cn-chengdu.aliyuncs.com/nature-1563109-wallhere.com.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MyBatis学习笔记"/></a><div class="content"><a class="title" href="/2025/12/11/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="MyBatis学习笔记">MyBatis学习笔记</a><time datetime="2025-12-11T02:55:00.000Z" title="发表于 2025-12-11 10:55:00">2025-12-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/11/HTTP%E3%80%81HTTPS%E5%92%8CTCP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="HTTP、HTTPS和TCP学习笔记"><img src="https://liverainy-blog-images.oss-cn-chengdu.aliyuncs.com/%E6%96%87%E7%AB%A0/pixiv/118131919_p0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HTTP、HTTPS和TCP学习笔记"/></a><div class="content"><a class="title" href="/2025/12/11/HTTP%E3%80%81HTTPS%E5%92%8CTCP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="HTTP、HTTPS和TCP学习笔记">HTTP、HTTPS和TCP学习笔记</a><time datetime="2025-12-11T02:16:11.000Z" title="发表于 2025-12-11 10:16:11">2025-12-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/09/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="JVM学习笔记"><img src="https://liverainy-blog-images.oss-cn-chengdu.aliyuncs.com/%E6%96%87%E7%AB%A0/pixiv/117521539_p0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM学习笔记"/></a><div class="content"><a class="title" href="/2025/12/09/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="JVM学习笔记">JVM学习笔记</a><time datetime="2025-12-09T07:15:37.000Z" title="发表于 2025-12-09 15:15:37">2025-12-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://liverainy-blog-images.oss-cn-chengdu.aliyuncs.com/5120x2880-px-artwork-fiction-nebula-science-space-1819213-wallhere.com.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Live Rainy</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><div class="js-pjax"></div><script async data-pjax src="/"></script></div></body></html>